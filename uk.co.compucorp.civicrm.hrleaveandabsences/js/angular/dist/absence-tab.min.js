eval("/* eslint-env amd */\n\n(function (require) {\n  define('leave-absences/shared/config',[],function () {\n    var srcPath = CRM.vars.leaveAndAbsences.baseURL + '/js/angular/src/leave-absences/shared';\n\n    // This require.config will picked up by the r.js optimizer\n    require.config({\n      paths: {\n        'leave-absences/shared/ui-router': 'leave-absences/shared/vendor/angular-ui-router.min',\n        'mocks': '../test/mocks'\n      },\n      shim: {\n        'leave-absences/shared/ui-router': {}\n      }\n    });\n\n    // This require.config will be used by the \"live\" RequireJS (with debug ON)\n    require.config({\n      paths: {\n        'leave-absences/shared/ui-router': srcPath + '/vendor/angular-ui-router.min',\n        'mocks': CRM.vars.leaveAndAbsences.baseURL + '/js/angular/test/mocks'\n      }\n    });\n  });\n})(require);\n\n//# sourceURL=/leave-absences/shared/config.js"),eval("/* eslint-env amd */\n\n(function (CRM) {\n  define('leave-absences/shared/modules/shared-settings',[\n    'common/angular'\n  ], function (angular) {\n    return angular.module('leave-absences.settings', []).constant('shared-settings', {\n      attachmentToken: CRM.vars.leaveAndAbsences.attachmentToken,\n      debug: CRM.debug,\n      managerPathTpl: CRM.vars.leaveAndAbsences.baseURL + '/views/manager-leave/',\n      sharedPathTpl: CRM.vars.leaveAndAbsences.baseURL + '/views/shared/',\n      serverDateFormat: 'YYYY-MM-DD',\n      serverDateTimeFormat: 'YYYY-MM-DD HH:mm:ss',\n      permissions: {\n        admin: {\n          access: 'access leave and absences',\n          administer: 'administer leave and absences'\n        },\n        ssp: {\n          access: 'access leave and absences in ssp',\n          manage: 'manage leave and absences in ssp'\n        }\n      },\n      fileUploader: {\n        queueLimit: 10\n      },\n      statusNames: {\n        approved: 'approved',\n        adminApproved: 'admin_approved',\n        awaitingApproval: 'awaiting_approval',\n        moreInformationRequired: 'more_information_required',\n        rejected: 'rejected',\n        cancelled: 'cancelled'\n      }\n    });\n  });\n})(CRM);\n\n//# sourceURL=/leave-absences/shared/modules/shared-settings.js"),eval("define('leave-absences/shared/modules/apis',[\n  'common/angular',\n  'common/modules/apis',\n  'leave-absences/shared/modules/shared-settings',\n], function (angular) {\n  'use strict';\n\n  return angular.module('leave-absences.apis', [\n    'common.apis',\n    'leave-absences.settings'\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/apis.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/modules/models-instances',[\n  'common/angular',\n  'common/models/instances/instance',\n  'common/modules/services',\n  'common/modules/models',\n  'common/services/check-permissions',\n  'leave-absences/shared/modules/shared-settings'\n], function (angular) {\n  'use strict';\n\n  return angular.module('leave-absences.models.instances', [\n    'common.models',\n    'common.models.instances',\n    'common.services',\n    'leave-absences.settings'\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/models-instances.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/modules/models',[\n  'common/angular',\n  'common/modules/models',\n  'common/modules/services',\n  'leave-absences/shared/modules/apis',\n  'leave-absences/shared/modules/models-instances',\n  'leave-absences/shared/modules/shared-settings'\n], function (angular) {\n  'use strict';\n\n  return angular.module('leave-absences.models', [\n    'common.models',\n    'common.services',\n    'leave-absences.apis',\n    'leave-absences.models.instances',\n    'leave-absences.settings'\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/models.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/absence-type.api',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/apis',\n  'common/services/api'\n], function (_, moment, apis) {\n  'use strict';\n\n  apis.factory('AbsenceTypeAPI', ['$log', 'api', 'shared-settings', function ($log, api, sharedSettings) {\n    $log.debug('AbsenceTypeAPI');\n\n    return api.extend({\n\n      /**\n       * This method returns all the active AbsenceTypes unless specified in param.\n       *\n       * @param  {Object} params  matches the api endpoint params (title, weight etc)\n       * @return {Promise}\n       */\n      all: function (params) {\n        $log.debug('AbsenceTypeAPI.all');\n\n        return this.sendGET('AbsenceType', 'get', _.defaults(params || {}, { is_active: true }))\n          .then(function (data) {\n            return data.values;\n          });\n      },\n\n      /**\n       * Calculate Toil Expiry Date\n       *\n       * @param  {string} absenceTypeID\n       * @param  {Object} date\n       * @param  {Object} params\n       * @return {Promise}\n       */\n      calculateToilExpiryDate: function (absenceTypeID, date, params) {\n        $log.debug('AbsenceTypeAPI.calculateToilExpiryDate');\n\n        params = _.assign({}, params, {\n          absence_type_id: absenceTypeID,\n          date: moment(date).format(sharedSettings.serverDateFormat)\n        });\n\n        return this.sendPOST('AbsenceType', 'calculateToilExpiryDate', params)\n          .then(function (data) {\n            return data.values.expiry_date;\n          });\n      }\n    });\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/absence-type.api.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/absence-type.instance',[\n  'leave-absences/shared/modules/models-instances',\n  'common/models/instances/instance'\n], function (instances) {\n  'use strict';\n\n  instances.factory('AbsenceTypeInstance', ['$log', 'ModelInstance', function ($log, ModelInstance) {\n    $log.debug('AbsenceTypeInstance');\n\n    return ModelInstance.extend({});\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/absence-type.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/absence-type.model',[\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'leave-absences/shared/apis/absence-type.api',\n  'leave-absences/shared/instances/absence-type.instance'\n], function (models) {\n  'use strict';\n\n  models.factory('AbsenceType', [\n    '$log', 'Model', 'AbsenceTypeAPI', 'AbsenceTypeInstance',\n    function ($log, Model, absenceTypeAPI, instance) {\n      $log.debug('AbsenceType');\n\n      return Model.extend({\n        /**\n         * Calls the all() method of the AbsenceType API, and returns an\n         * AbsenceTypeInstance for each absenceType.\n         *\n         * @param  {Object} params  matches the api endpoint params (title, weight etc)\n         * @return {Promise}\n         */\n        all: function (params) {\n          return absenceTypeAPI.all(params)\n            .then(function (absenceTypes) {\n              return absenceTypes.map(function (absenceType) {\n                return instance.init(absenceType, true);\n              });\n            });\n        },\n\n        /**\n         * Calls the calculateToilExpiryDate() method of the AbsenceType API\n         *\n         * @param  {string} absenceTypeID\n         * @param  {Object} date\n         * @param  {Object} params\n         * @return {Promise}\n         */\n        calculateToilExpiryDate: function (absenceTypeID, date, params) {\n          return absenceTypeAPI.calculateToilExpiryDate(absenceTypeID, date, params);\n        },\n\n        /**\n         * Determines if the absence type can expire by querying if\n         * the expiration unit and duration are not null.\n         *\n         * @param   {string} absenceTypeId\n         * @return  {Promise}\n         */\n        canExpire: function (absenceTypeId) {\n          return absenceTypeAPI.all({\n            accrual_expiration_unit: { 'IS NOT NULL': 1 },\n            accrual_expiration_duration: { 'IS NOT NULL': 1 },\n            allow_accruals_request: 1,\n            id: absenceTypeId,\n            options: { limit: 1 },\n            return: ['id']\n          })\n          .then(function (results) {\n            return results.length > 0;\n          });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/absence-type.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/work-pattern.api',[\n  'common/lodash',\n  'leave-absences/shared/modules/apis',\n  'common/services/api'\n], function (_, apis) {\n  'use strict';\n\n  apis.factory('WorkPatternAPI', ['$log', 'api', function ($log, api) {\n    $log.debug('WorkPatternAPI');\n\n    return api.extend({\n\n      /**\n       * Assigns a work pattern to a contact\n       *\n       * @param {string} contactId\n       * @param {string} workPatternID\n       * @param {string} effectiveDate\n       * @param {string} effectiveEndDate\n       * @param {string} changeReason\n       * @param {object} params - additional parameters\n       * @return {Promise}\n       */\n      assignWorkPattern: function (contactId, workPatternID, effectiveDate, effectiveEndDate, changeReason, params) {\n        return this.sendPOST('ContactWorkPattern', 'create', _.assign({}, params, {\n          contact_id: contactId,\n          pattern_id: workPatternID,\n          effective_date: effectiveDate,\n          effective_end_date: effectiveEndDate,\n          change_reason: changeReason\n        })).then(function (data) {\n          return data.values;\n        });\n      },\n\n      /**\n       * Returns all the work patterns\n       *\n       * @param {object} params additional parameters\n       * @return {Promise} Resolved with {Array} All Work Patterns\n       */\n      get: function (params) {\n        return this.sendGET('WorkPattern', 'get', params || {})\n          .then(function (data) {\n            return data.values;\n          });\n      },\n\n      /**\n       * Returns the calendar for the given contact(s) and the date range,\n       * as a list of days and their type\n       *\n       * @param {string/int/Array} contactId can be also an array for multiple contacts\n       * @param {string} startDate\n       * @param {string} endDate\n       * @param {object} params additional parameters\n       * @return {Promise} Resolved with {Array} All calendar records\n       */\n      getCalendar: function (contactId, startDate, endDate, params) {\n        $log.debug('WorkPatternAPI.getCalendar', contactId, startDate, endDate, params);\n\n        return this.sendGET('WorkPattern', 'getcalendar', _.assign({}, params, {\n          contact_id: _.isArray(contactId) ? { 'IN': contactId } : contactId,\n          start_date: startDate,\n          end_date: endDate\n        }));\n      },\n\n      /**\n       * Un assign a work pattern by the given contact work pattern ID\n       *\n       * @param {string} contactWorkPatternID\n       * @return {Promise}\n       */\n      unassignWorkPattern: function (contactWorkPatternID) {\n        return this.sendPOST('ContactWorkPattern', 'delete', {\n          id: contactWorkPatternID\n        });\n      },\n\n      /**\n       * Returns all the work patterns of a specific contact\n       *\n       * @param {string} contactId\n       * @param {object} params - additional parameters\n       * @param {boolean} cache\n       * @return {Promise} Resolved with {Array} All Work Patterns of the contact\n       */\n      workPatternsOf: function (contactId, params, cache) {\n        return this.sendGET('ContactWorkPattern', 'get', _.assign({}, params, {\n          contact_id: contactId,\n          'api.WorkPattern.get': { 'id': '$value.pattern_id' }\n        }), cache).then(function (data) {\n          data = data.values;\n\n          return data.map(storeWorkPattern);\n        });\n      }\n    });\n\n    /**\n     * ContactWorkPatterns data will have key 'api.WorkPattern.get'\n     * which is normalized with a friendlier 'workPatterns' key\n     *\n     * @param  {Object} workPattern\n     * @return {Object}\n     */\n    function storeWorkPattern (workPattern) {\n      var clone = _.clone(workPattern);\n\n      clone['workPattern'] = clone['api.WorkPattern.get']['values'][0];\n      delete clone['api.WorkPattern.get'];\n\n      return clone;\n    }\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/work-pattern.api.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/calendar.instance',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/models-instances',\n  'common/models/option-group',\n  'common/models/instances/instance'\n], function (_, moment, instances) {\n  'use strict';\n\n  instances.factory('CalendarInstance', [\n    '$log', '$q', 'ModelInstance', 'shared-settings', 'OptionGroup',\n    function ($log, $q, ModelInstance, sharedSettings, OptionGroup) {\n      var dayTypesPromise;\n\n      return ModelInstance.extend({\n\n        /**\n         * Returns the default custom data (as in, not given by the API)\n         * with its default values\n         *\n         * @return {object}\n         */\n        defaultCustomData: function () {\n          return {\n            days: []\n          };\n        },\n\n        /**\n         * Checks whether the given date is a non working day\n         *\n         * @param {Object} date\n         * @return {Promise} resolves to {Boolean}\n         */\n        isNonWorkingDay: function (date) {\n          return checkDateType.call(this, date, 'non_working_day');\n        },\n\n        /**\n         * Checks whether a date is a weekend\n         *\n         * @param {Object} date\n         * @return {Promise} resolves to {Boolean}\n         */\n        isWeekend: function (date) {\n          return checkDateType.call(this, date, 'weekend');\n        },\n\n        /**\n         * Checks whether the given date is a working day\n         *\n         * @param {Object} date\n         * @return {Promise} resolves to {Boolean}\n         */\n        isWorkingDay: function (date) {\n          return checkDateType.call(this, date, 'working_day');\n        },\n\n        /**\n         * Removes the `calendar` property and creates the `day` property\n         * which indexes the dates by their timestamp\n         *\n         * @param  {Object} attributes\n         * @return {Object}\n         */\n        transformAttributes: function (attributes) {\n          var datesObj = {};\n\n          // convert array to an object with the timestamp being the key\n          attributes.calendar.forEach(function (calendar) {\n            datesObj[getDateObjectWithFormat(calendar.date).valueOf()] = calendar;\n          });\n\n          return _(attributes).omit('calendar').assign({ days: datesObj }).value();\n        }\n      });\n\n      /**\n       * Checks whether a date matches the given type name\n       *\n       * @param {Object} date\n       * @param {string} typeName\n       *\n       * @return Promise resolves to {Boolean}\n       */\n      function checkDateType (date, typeName) {\n        return loadDayTypes()\n          .then(function (dayTypes) {\n            var searchedDate = this.days[getDateObjectWithFormat(date).valueOf()];\n\n            return searchedDate ? _.find(dayTypes, function (dayType) {\n              return dayType.name === typeName;\n            }).value === searchedDate.type : false;\n          }.bind(this));\n      }\n\n      /**\n       * Converts given date to moment object with server format\n       *\n       * @param {Date/String} date from server\n       * @return {Moment} Moment date\n       */\n      function getDateObjectWithFormat (date) {\n        return moment(date, sharedSettings.serverDateFormat).clone();\n      }\n\n      /**\n       * Fetches the list of day types OptionValues and stores the promise\n       * internally so that future calls will not make any more requests\n       *\n       * @return {Promise} resolves to {Array}\n       */\n      function loadDayTypes () {\n        dayTypesPromise = dayTypesPromise || OptionGroup.valuesOf('hrleaveandabsences_work_day_type');\n\n        return dayTypesPromise;\n      }\n    }]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/calendar.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/calendar.model',[\n  'common/lodash',\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'leave-absences/shared/apis/work-pattern.api',\n  'leave-absences/shared/instances/calendar.instance'\n], function (_, models) {\n  'use strict';\n\n  models.factory('Calendar', ['$log', 'Model', 'WorkPatternAPI', 'CalendarInstance',\n    function ($log, Model, workPatternAPI, instance) {\n      $log.debug('Calendar');\n\n      return Model.extend({\n\n        /**\n         * This method returns the calendar(s) for the given contact(s) and period,\n         * as a list of days and their type\n         *\n         * @param {string/int/Array} contactId can be also an array for multiple contacts\n         * @param {string} startDate\n         * @param {string} endDate\n         * @param {object} params additional parameters\n         * @return {Promise} resolves with CalendarInstance(s)\n         */\n        get: function (contactId, startDate, endDate, params) {\n          $log.debug('Calendar.get');\n\n          return workPatternAPI.getCalendar(contactId, startDate, endDate, params)\n            .then(function (data) {\n              var list = data.values.map(function (contactCalendar) {\n                return instance.init(contactCalendar);\n              });\n\n              return _.isArray(contactId) ? list : list[0];\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/calendar.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/entitlement.api',[\n  'leave-absences/shared/modules/apis',\n  'common/lodash',\n  'common/services/api'\n], function (apis, _) {\n  'use strict';\n\n  apis.factory('EntitlementAPI', ['$log', 'api', function ($log, api) {\n    $log.debug('EntitlementAPI');\n\n    /**\n     * Entitlements data will have key 'api.LeavePeriodEntitlement.getremainder'\n     * which is normalized with a friendlier 'remainder' key\n     *\n     * @param  {Object} entitlement\n     * @return {Object}\n     */\n    function storeRemainder (entitlement) {\n      var clone = _.clone(entitlement);\n      var remainderValues = clone['api.LeavePeriodEntitlement.getremainder']['values'];\n\n      if (remainderValues.length) {\n        clone['remainder'] = remainderValues[0]['remainder'];\n      }\n\n      delete clone['api.LeavePeriodEntitlement.getremainder'];\n\n      return clone;\n    }\n\n    /**\n     * Entitlements data will have key 'api.LeavePeriodEntitlement.getentitlement'\n     * which is normalized with a friendlier 'value' key\n     *\n     * @param  {Object} entitlement\n     * @return {Object}\n     */\n    function storeValue (entitlement) {\n      var clone = _.clone(entitlement);\n      var value = clone['api.LeavePeriodEntitlement.getentitlement'].values[0].entitlement;\n\n      clone['value'] = value;\n      delete clone['api.LeavePeriodEntitlement.getentitlement'];\n\n      return clone;\n    }\n\n    return api.extend({\n\n      /**\n       * This method returns all the entitlements.\n       *\n       * It chains an additional call to the `getentitlement` endpoint to also return\n       * the actual value of each entitlement\n       *\n       * It can also return the remainder (current and future) among the rest of\n       * the data when passed withRemainder.\n       *\n       * @param  {Object} params  matches the api endpoint params (period_id, contact_id, etc)\n       * @param  {boolean} withRemainder  can be set to true to return remainder of entitlements\n       * @return {Promise}\n       */\n      all: function (params, withRemainder) {\n        $log.debug('EntitlementAPI.all');\n\n        params['api.LeavePeriodEntitlement.getentitlement'] = {\n          'entitlement_id': '$value.id'\n        };\n\n        if (withRemainder) {\n          params['api.LeavePeriodEntitlement.getremainder'] = {\n            'entitlement_id': '$value.id',\n            'include_future': true\n          };\n        }\n\n        return this.sendGET('LeavePeriodEntitlement', 'get', params, false)\n          .then(function (data) {\n            return data.values;\n          })\n          .then(function (entitlements) {\n            entitlements = entitlements.map(storeValue);\n\n            if (withRemainder) {\n              entitlements = entitlements.map(storeRemainder);\n            }\n\n            return entitlements;\n          });\n      },\n      /**\n       * This method returns the breakdown of entitlement from various types of leave balances.\n       *\n       * @param  {Object} params  matches the api endpoint params (period_id, contact_id, etc)\n       * @return {Promise}  will return a promise which when resolved will contain breakdown\n       * details along with entitlement id\n       */\n      breakdown: function (params) {\n        $log.debug('EntitlementAPI.breakdown');\n\n        return this.sendGET('LeavePeriodEntitlement', 'getbreakdown', params)\n          .then(function (data) {\n            return data.values;\n          });\n      },\n      /**\n       * This method returns the balance report\n       *\n       * @param  {Object}  filters\n       * @param  {Object}  pagination\n       * @param  {Object}  sort\n       * @param  {Object}  additionalParams\n       * @param  {Boolean} cache\n       * @return {Promise} resolves contacts with absence types with balances\n       */\n      getLeaveBalances: function (filters, pagination, sort, additionalParams, cache) {\n        $log.debug('EntitlementAPI.getLeaveBalances');\n\n        return this.getAll('LeavePeriodEntitlement', filters, pagination, sort,\n          additionalParams, 'getLeaveBalances', cache);\n      }\n    });\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/entitlement.api.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/entitlement.instance',[\n  'leave-absences/shared/modules/models-instances',\n  'common/models/instances/instance'\n], function (instances) {\n  'use strict';\n\n  instances.factory('EntitlementInstance', ['$log', 'ModelInstance', 'EntitlementAPI', function ($log, ModelInstance, EntitlementAPI) {\n    $log.debug('EntitlementInstance');\n\n    return ModelInstance.extend({\n      /**\n       * Returns the default custom data (as in, not given by the Entitlement API)\n       * with its default values\n       *\n       * @return {object}\n       */\n      defaultCustomData: function () {\n        return {\n          remainder: {\n            current: 0,\n            future: 0\n          },\n          breakdown: []\n        };\n      },\n\n      /**\n       * Populates the breakdown of the entitlement, by passing to the api\n       * the entitlement id.\n       *\n       * @return {Promise} with updated entitlement model instance with the side\n       * effect of setting this.breakdown property to newly obtained entitlement breakdown\n       */\n      getBreakdown: function () {\n        return EntitlementAPI.breakdown({\n          entitlement_id: this.id\n        })\n        .then(function (breakdown) {\n          this.breakdown = breakdown;\n        }.bind(this));\n      }\n    });\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/entitlement.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/entitlement.model',[\n  'common/lodash',\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'leave-absences/shared/apis/entitlement.api',\n  'leave-absences/shared/instances/entitlement.instance'\n], function (_, models) {\n  'use strict';\n\n  models.factory('Entitlement', [\n    '$log', 'Model', 'EntitlementAPI', 'EntitlementInstance',\n    function ($log, Model, entitlementAPI, instance) {\n      $log.debug('Entitlement');\n\n      return Model.extend({\n        /**\n         * Calls the all() method of the Entitlement API, and returns an\n         * EntitlementInstance for each entitlement.\n         * It can pass the withRemainder property to get remainder for entitlements.\n         *\n         * @param {Object} params matches the api endpoint params (period_id, contact_id, etc)\n         * @param {boolean} withRemainder to return remainder of data\n         * @return {Promise}\n         */\n        all: function (params, withRemainder) {\n          return entitlementAPI.all(this.processFilters(params), withRemainder)\n            .then(function (entitlements) {\n              return entitlements.map(function (entitlement) {\n                return instance.init(entitlement, true);\n              });\n            });\n        },\n        /**\n         * Calls the `breakdown` method of the entitlement API\n         *\n         * The return value of the promise changes based on whether an array of `EntitlementInstance`s\n         * has been passed to the method or not.\n         *\n         * If it hasn 't, then it returns the entitlements along with breakdown details based on params passed.\n         * If it has, then it loads the breakdown data into each correspondent entitlement, which then\n         * are returned back.\n         *\n         * @param {Object} params matches the api endpoint params (period_id, contact_id, etc)\n         * @param {Array}  [entitlements] an array of `EntitlementInstance`s\n         * @return {Promise}\n         */\n        breakdown: function (params, entitlements) {\n          return entitlementAPI.breakdown(params)\n            .then(function (breakdown) {\n              if (entitlements) {\n                entitlements.map(function (entitlement) {\n                  var foundEntitlement = _.find(breakdown, function (element) {\n                    return element.id === entitlement.id;\n                  });\n\n                  if (foundEntitlement) {\n                    entitlement['breakdown'] = foundEntitlement['breakdown'];\n                  }\n\n                  return entitlement;\n                });\n\n                return entitlements;\n              }\n\n              return breakdown.map(function (entitlement) {\n                return instance.init(entitlement, true);\n              });\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/entitlement.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/leave-request.api',[\n  'leave-absences/shared/modules/apis',\n  'common/lodash',\n  'common/services/api'\n], function (apis, _) {\n  'use strict';\n\n  apis.factory('LeaveRequestAPI', ['$log', 'api', '$q', 'shared-settings',\n    function ($log, api, $q) {\n      $log.debug('LeaveRequestAPI');\n\n      return api.extend({\n\n        /**\n         * This method returns all the Leave Requests.\n         * It supports filters, pagination, sort and extra params\n         *\n         * @param {object} filters - Values the full list should be filtered by\n         * @param {object} pagination\n         *   `page` for the current page, `size` for number of items per page\n         * @param {string} sort - The field and direction to order by\n         * @param  {Object} params\n         * @param  {Boolean} cache\n         * @return {Promise} Resolved with {Object} All leave requests\n         */\n        all: function (filters, pagination, sort, params, cache) {\n          $log.debug('LeaveRequestAPI.all');\n          var defer = $q.defer();\n\n          // if contact_id has an empty array for IN condition, there is no point making the\n          // call to the Leave Request API\n          // TODO Move to Base API\n          if (filters && filters.contact_id && filters.contact_id.IN && filters.contact_id.IN.length === 0) {\n            defer.resolve({ list: [], total: 0, allIds: [] });\n          } else {\n            defer.resolve(this.getAll('LeaveRequest', filters, pagination, sort, params, 'getFull', cache));\n          }\n\n          return defer.promise;\n        },\n\n        /**\n         * This method returns all the total change in balance that is caused by the\n         * leave requests of a given absence type, or of all the absence types of a given contact and period.\n         *\n         * @param {string} contactId The ID of the Contact to get the balance change for\n         * @param {string} periodId The ID of the Absence Period to get the balance change for\n         * @param {array} [statuses = null] An array of OptionValue values which the list will be filtered by\n         * @param {boolean} [isPublicHoliday=false] Based on the value of this param,\n         * the calculation will include only the leave requests that aren't/are public holidays\n         * @return {Promise} Resolved with {Object} Balance Change data or Error data\n         */\n        balanceChangeByAbsenceType: function (contactId, periodId, statuses, isPublicHoliday) {\n          $log.debug('LeaveRequestAPI.balanceChangeByAbsenceType');\n          var deferred = $q.defer();\n\n          if (!contactId || !periodId) {\n            deferred.reject('contact_id and period_id are mandatory');\n          }\n\n          var params = {\n            contact_id: contactId,\n            period_id: periodId,\n            statuses: statuses ? {'IN': statuses} : null,\n            public_holiday: isPublicHoliday || false\n          };\n\n          this.sendGET('LeaveRequest', 'getbalancechangebyabsencetype', params, false)\n          .then(function (data) {\n            deferred.resolve(data.values);\n          });\n\n          return deferred.promise;\n        },\n\n        /**\n         * Gets the overall balance change after a leave request is created. The\n         * API will create and return the detailed breakdown of it in days.\n         *\n         * @param {Object} params matched the API end point params like\n         * mandatory values for contact_id, from_date, from_date_type and optional values for\n         * to_date and to_date_type.\n         *\n         * @return {Promise} containing the detailed breakdown of balance leaves\n         */\n        calculateBalanceChange: function (params) {\n          $log.debug('LeaveRequestAPI.calculateBalanceChange', params);\n          var deferred = $q.defer();\n\n          if (params && (!params.contact_id || !params.from_date || !params.from_date_type)) {\n            deferred.reject('contact_id, from_date and from_date_type in params are mandatory');\n          }\n\n          this.sendPOST('LeaveRequest', 'calculatebalancechange', params)\n          .then(function (data) {\n            deferred.resolve(data.values);\n          });\n\n          return deferred.promise;\n        },\n\n        /**\n         * Gets the balance change breakdown\n         * @NOTE: This breakdown is not affected by a work pattern change\n         *\n         * @param  {Integer} leaveRequestId Leave Request ID\n         * @return {Promise} resolves with the detailed balance breakdown\n         */\n        getBalanceChangeBreakdown: function (leaveRequestId) {\n          return this.sendGET('LeaveRequest', 'getBreakdown',\n            { leave_request_id: leaveRequestId }, false);\n        },\n\n        /**\n         * Create a new leave request with given params.\n         *\n         * @param {Object} params matched the API end point params with\n         * mandatory values for contact_id, status_id, from_date, from_date_type\n         * and optional values for to_date and to_date_type.\n         * If to_date is given then to_date_type is also mandotory.\n         *\n         * @return {Promise} containing the leave request object additionally with id key set\n         * else rejects the promise with error data\n         */\n        create: function (params) {\n          $log.debug('LeaveRequestAPI.create', params);\n          var deferred = $q.defer();\n\n          if (params) {\n            if (params.to_date && !params.to_date_type) {\n              deferred.reject('to_date_type is mandatory');\n            } else if (!params.contact_id || !params.from_date || !params.from_date_type || !params.status_id) {\n              deferred.reject('contact_id, from_date, status_id and from_date_type params are mandatory');\n            }\n          }\n\n          this.sendPOST('LeaveRequest', 'create', params)\n          .then(function (data) {\n            deferred.resolve(data.values[0]);\n          });\n\n          return deferred.promise;\n        },\n\n        /**\n         * Calls the `delete` endpoint with the given leave request id\n         *\n         * @param  {int/string} id\n         * @return {Promise}\n         */\n        delete: function (id) {\n          return this.sendPOST('LeaveRequest', 'delete', { id: id });\n        },\n\n        /**\n         * Calls the deletecomment backend API.\n         *\n         * @param {String} leaveRequestID - leave request ID\n         * @param {String} attachmentID - attachment ID\n         * @param {Object} params\n         *\n         * @return {Promise}\n         */\n        deleteAttachment: function (leaveRequestID, attachmentID, params) {\n          params = _.assign({}, params, {\n            leave_request_id: leaveRequestID,\n            attachment_id: attachmentID\n          });\n\n          return this.sendPOST('LeaveRequest', 'deleteattachment', params)\n          .then(function (result) {\n            return result.values;\n          });\n        },\n\n        /**\n         * Calls the deletecomment backend API.\n         *\n         * @param {String} commentID - comment ID\n         * @param {Object} params\n         *\n         * @return {Promise}\n         */\n        deleteComment: function (commentID, params) {\n          params = _.assign({}, params, {\n            comment_id: commentID\n          });\n\n          return this.sendPOST('LeaveRequest', 'deletecomment', params)\n          .then(function (commentsData) {\n            return commentsData.values;\n          });\n        },\n\n        /**\n         * Get leave request for the given id\n         *\n         * @param {object} id - leave request id\n         *\n         * @return {Promise} resolves with {Object}\n         */\n        find: function (id) {\n          $log.debug('LeaveRequestAPI.find');\n\n          return this.sendGET('LeaveRequest', 'getFull', { id: id })\n          .then(function (response) {\n            if (response.values.length === 0) {\n              return $q.reject('LeaveRequest not found with this ID');\n            }\n\n            return response.values[0];\n          });\n        },\n\n        /**\n         * Calls the getattachments backend API.\n         *\n         * @param {String} leaveRequestID - ID of leave request\n         * @param {Object} params\n         *\n         * @return {Promise}\n         */\n        getAttachments: function (leaveRequestID, params) {\n          params = _.assign({}, params, {\n            leave_request_id: leaveRequestID\n          });\n\n          return this.sendGET('LeaveRequest', 'getattachments', params, false)\n          .then(function (attachments) {\n            return attachments.values;\n          });\n        },\n\n        /**\n         * Calls the getcomment backend API.\n         *\n         * @param {String} leaveRequestID - ID of leave request\n         * @param {Object} params\n         *\n         * @return {Promise}\n         */\n        getComments: function (leaveRequestID, params) {\n          params = _.assign({}, params, {\n            leave_request_id: leaveRequestID\n          });\n\n          return this.sendGET('LeaveRequest', 'getcomment', params, false)\n          .then(function (commentsData) {\n            return commentsData.values;\n          });\n        },\n\n        /**\n         * Calls the isManagedBy backend API.\n         *\n         * @param {String} leaveRequestID - ID of leave request\n         * @param {String} contactID - ID of contact\n         * @return {Promise} resolves with an {Boolean}\n         */\n        isManagedBy: function (leaveRequestID, contactID) {\n          $log.debug('LeaveRequestAPI.isManagedBy');\n\n          return this.sendPOST('LeaveRequest', 'isManagedBy', {\n            leave_request_id: leaveRequestID,\n            contact_id: contactID\n          })\n          .then(function (response) {\n            return response.values;\n          });\n        },\n\n        /**\n         * Validate params for a new new leave request. It can be used before\n         * creating a leave request to validate data.\n         *\n         * @param {Object} params matched the API end point params with\n         * values like contact_id, status_id, from_date, from_date_type etc.,\n         * @return {Promise} returns an array of errors for invalid data else empty array\n         */\n        isValid: function (params) {\n          $log.debug('LeaveRequestAPI.isValid', params);\n          var deferred = $q.defer();\n\n          this.sendPOST('LeaveRequest', 'isValid', params)\n          .then(function (data) {\n            if (data.count > 0) {\n              deferred.reject(_(data.values).map().flatten().value());\n            } else {\n              deferred.resolve(data.values);\n            }\n          });\n\n          return deferred.promise;\n        },\n\n        /**\n         * Calls the addcomment backend API.\n         *\n         * @param {string} leaveRequestID - ID of Leave Request\n         * @param {Object} comment - Comment object\n         * @param {Object} params\n         *\n         * @return {Promise}\n         */\n        saveComment: function (leaveRequestID, comment, params) {\n          params = _.assign({}, params, {\n            leave_request_id: leaveRequestID,\n            text: comment.text,\n            contact_id: comment.contact_id\n          });\n\n          return this.sendPOST('LeaveRequest', 'addcomment', params)\n          .then(function (commentsData) {\n            return commentsData.values;\n          });\n        },\n\n        /**\n         * This method is used to update a leave request\n         *\n         * @param {object} params - Updated values of leave request\n         * @return {Promise} Resolved with {Object} Updated Leave request\n         */\n        update: function (params) {\n          $log.debug('LeaveRequestAPI.update', params);\n          var deferred = $q.defer();\n\n          if (!params.id) {\n            deferred.reject('id is mandatory field');\n          }\n\n          return this.sendPOST('LeaveRequest', 'create', params)\n          .then(function (data) {\n            return data.values[0];\n          });\n        }\n      });\n    }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/leave-request.api.js"),
eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/leave-request.instance',[\n  'common/lodash',\n  'leave-absences/shared/modules/models-instances',\n  'common/models/option-group',\n  'common/models/instances/instance'\n\n], function (_, instances) {\n  'use strict';\n\n  instances.factory('LeaveRequestInstance', ['$q', 'checkPermissions', 'OptionGroup',\n    'shared-settings', 'ModelInstance', 'LeaveRequestAPI',\n    function ($q, checkPermissions, OptionGroup, sharedSettings, ModelInstance, LeaveRequestAPI) {\n      /**\n       * Update status ID\n       *\n       * @param {string} status - name of the option value\n       * @return {Promise} Resolved with {Object} - Error Data in case of error\n       */\n      function changeLeaveStatus (status) {\n        return getOptionIDByName(status)\n          .then(function (statusId) {\n            var originalStatus = this.status_id;\n\n            this.status_id = statusId.value;\n            return this.update()\n              .catch(function (error) {\n                // Revert status id back in case of exception\n                this.status_id = originalStatus;\n\n                return $q.reject(error);\n              }.bind(this));\n          }.bind(this));\n      }\n\n      /**\n       * Checks if a LeaveRequest is of a specific type\n       *\n       * @param {string} statusName - name of the option value\n       * @return {Promise} Resolved with {Boolean}\n       */\n      function checkLeaveStatus (statusName) {\n        return getOptionIDByName(statusName)\n          .then(function (statusObj) {\n            return this.status_id === statusObj.value;\n          }.bind(this));\n      }\n\n      /**\n       * Deletes the given attachment from server. It iterates through local\n       * files array to find which are to be deleted and deletes them.\n       *\n       * @return {Promise}\n       */\n      function deleteAttachments () {\n        var promises = [];\n\n        _.forEach(this.files, function (file) {\n          if (file.toBeDeleted) {\n            promises.push(LeaveRequestAPI.deleteAttachment(this.id, file.attachment_id));\n          }\n        }.bind(this));\n\n        return $q.all(promises);\n      }\n\n      /**\n       * Get ID of an option value\n       *\n       * @param {string} name - name of the option value\n       * @return {Promise} Resolved with {Object} - Specific leave request\n       */\n      function getOptionIDByName (name) {\n        return OptionGroup.valuesOf('hrleaveandabsences_leave_request_status')\n          .then(function (data) {\n            return data.find(function (statusObj) {\n              return statusObj.name === name;\n            });\n          });\n      }\n\n      /**\n       * Save comments which do not have an ID and delete comments which are marked for deletion\n       *\n       * @return {Promise}\n       */\n      function saveAndDeleteComments () {\n        var leaveRequestId = this.id;\n        var promises = [];\n\n        // Pushing a chain of API calls to create new comments sequentially\n        promises.push($q.sequence(this.comments.filter(function (comment) {\n          return !comment.comment_id;\n        }).map(function (comment) {\n          return function () {\n            return LeaveRequestAPI.saveComment(leaveRequestId, comment);\n          };\n        })));\n\n        // Deleting comments can done in parallel, no need in a promise chain\n        promises = promises.concat(this.comments.filter(function (comment) {\n          return comment.comment_id && comment.toBeDeleted;\n        }).map(function (comment) {\n          return LeaveRequestAPI.deleteComment(comment.comment_id);\n        }));\n\n        return $q.all(promises);\n      }\n\n      return ModelInstance.extend({\n\n        /**\n         * Returns the default custom data (as in, not given by the API)\n         * with its default values\n         *\n         * @return {object}\n         */\n        defaultCustomData: function () {\n          return {\n            comments: [],\n            files: [],\n            request_type: 'leave'\n          };\n        },\n\n        /**\n         * Gets the current balance change according to a current work pattern\n         *\n         * @return {Promise} resolves to an object containing\n         *   a balance change amount and a detailed breakdown\n         */\n        calculateBalanceChange: function () {\n          return LeaveRequestAPI.calculateBalanceChange(\n            _.pick(this, ['contact_id', 'from_date',\n              'from_date_type', 'to_date', 'to_date_type']));\n        },\n\n        /**\n         * Cancel a leave request\n         */\n        cancel: function () {\n          return changeLeaveStatus.call(this, sharedSettings.statusNames.cancelled);\n        },\n\n        /**\n         * Approve a leave request\n         */\n        approve: function () {\n          return changeLeaveStatus.call(this, sharedSettings.statusNames.approved);\n        },\n\n        /**\n         * Reject a leave request\n         */\n        reject: function () {\n          return changeLeaveStatus.call(this, sharedSettings.statusNames.rejected);\n        },\n\n        /**\n         * Sends a leave request back as more information is required\n         */\n        sendBack: function () {\n          return changeLeaveStatus.call(this, sharedSettings.statusNames.moreInformationRequired);\n        },\n\n        /**\n         * Update a leave request\n         *\n         * @return {Promise} Resolved with {Object} Updated Leave request\n         */\n        update: function () {\n          return LeaveRequestAPI.update(this.toAPI())\n            .then(function () {\n              return $q.all([\n                saveAndDeleteComments.call(this),\n                deleteAttachments.call(this)\n              ]);\n            }.bind(this));\n        },\n\n        /**\n         * Create a new leave request\n         *\n         * @return {Promise} Resolved with {Object} Created Leave request with\n         *  newly created id for this instance\n         */\n        create: function () {\n          return LeaveRequestAPI.create(this.toAPI())\n            .then(function (result) {\n              this.id = result.id;\n\n              return $q.all([\n                saveAndDeleteComments.call(this)\n              ]);\n            }.bind(this));\n        },\n\n        /**\n         * Sets the flag to mark file for deletion. The file is not yet deleted\n         * from the server.\n         *\n         * @param {Object} file - Attachment object\n         */\n        deleteAttachment: function (file) {\n          if (!file.toBeDeleted) {\n            file.toBeDeleted = true;\n          }\n        },\n\n        /**\n         * Removes a comment from memory\n         *\n         * @param {Object} commentObj - comment object\n         */\n        deleteComment: function (commentObj) {\n          // If its an already saved comment, mark a toBeDeleted flag\n          if (commentObj.comment_id) {\n            commentObj.toBeDeleted = true;\n            return;\n          }\n\n          this.comments = _.reject(this.comments, function (comment) {\n            return commentObj.created_at === comment.created_at && commentObj.text === comment.text;\n          });\n        },\n\n        /**\n         * Deletes the leave request\n         *\n         * @return {Promise}\n         */\n        delete: function () {\n          return LeaveRequestAPI.delete(this.id);\n        },\n\n        /**\n         * Gets the balance change breakdown of the leave request\n         *\n         * @return {Promise}\n         */\n        getBalanceChangeBreakdown: function () {\n          return LeaveRequestAPI.getBalanceChangeBreakdown(this.id)\n            .then(function (response) {\n              return {\n                amount: _.reduce(response.values, function (sum, entry) {\n                  return sum + parseFloat(entry.amount);\n                }, 0),\n                breakdown: response.values.map(function (entry) {\n                  return {\n                    amount: parseFloat(entry.amount),\n                    date: entry.date,\n                    type: {\n                      id: entry.id,\n                      value: entry.type,\n                      label: entry.label\n                    }\n                  };\n                })\n              };\n            });\n        },\n\n        /**\n         * Validate leave request instance attributes.\n         *\n         * @return {Promise} empty array if no error found otherwise an object\n         *  with is_error set and array of errors\n         */\n        isValid: function () {\n          return LeaveRequestAPI.isValid(this.toAPI());\n        },\n\n        /**\n         * Checks if a LeaveRequest is Approved.\n         *\n         * @return {Promise} resolved with {Boolean}\n         */\n        isApproved: function () {\n          return checkLeaveStatus.call(this, sharedSettings.statusNames.approved);\n        },\n\n        /**\n         * Checks if a LeaveRequest is AwaitingApproval.\n         *\n         * @return {Promise} resolved with {Boolean}\n         */\n        isAwaitingApproval: function () {\n          return checkLeaveStatus.call(this, sharedSettings.statusNames.awaitingApproval);\n        },\n\n        /**\n         * Checks if a LeaveRequest is cancelled.\n         *\n         * @return {Promise} resolved with {Boolean}\n         */\n        isCancelled: function () {\n          return checkLeaveStatus.call(this, sharedSettings.statusNames.cancelled);\n        },\n\n        /**\n         * Checks if a LeaveRequest is Rejected.\n         *\n         * @return {Promise} resolved with {Boolean}\n         */\n        isRejected: function () {\n          return checkLeaveStatus.call(this, sharedSettings.statusNames.rejected);\n        },\n\n        /**\n         * Checks if a LeaveRequest is Sent Back.\n         *\n         * @return {Promise} resolved with {Boolean}\n         */\n        isSentBack: function () {\n          return checkLeaveStatus.call(this, sharedSettings.statusNames.moreInformationRequired);\n        },\n\n        /**\n         * Loads comments for this leave request.\n         *\n         * @return {Promise}\n         */\n        loadComments: function () {\n          if (this.id) {\n            return LeaveRequestAPI.getComments(this.id)\n              .then(function (comments) {\n                this.comments = comments;\n              }.bind(this));\n          }\n\n          return $q.resolve();\n        },\n\n        /**\n         * Check the role of a given contact in relationship to the leave request.\n         *\n         * @param {Object} contactId\n         * @return {Promise} resolves with an {String} - owner/admin/manager/none\n         */\n        roleOf: function (contactId) {\n          return (this.contact_id === contactId)\n            ? $q.resolve('owner')\n            : checkPermissions(sharedSettings.permissions.admin.administer)\n              .then(function (isAdmin) {\n                return isAdmin\n                  ? 'admin'\n                  : LeaveRequestAPI.isManagedBy(this.id, contactId)\n                    .then(function (isManager) {\n                      return isManager ? 'manager' : 'none';\n                    });\n              }.bind(this));\n        },\n\n        /**\n         * Override of parent method\n         *\n         * @param {object} result - The accumulator object\n         * @param {string} key - The property name\n         */\n        toAPIFilter: function (result, __, key) {\n          if (!_.includes(['balance_change', 'dates', 'comments', 'files'], key)) {\n            result[key] = this[key];\n          }\n        },\n\n        /**\n         * Loads file attachments associated with this leave request\n         *\n         * @return {Promise} with array of attachments if leave request is already created else empty promise\n         */\n        loadAttachments: function () {\n          if (this.id) {\n            return LeaveRequestAPI.getAttachments(this.id)\n              .then(function (attachments) {\n                this.files = attachments;\n              }.bind(this));\n          }\n\n          return $q.resolve();\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/leave-request.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/leave-request.model',[\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'leave-absences/shared/apis/leave-request.api',\n  'leave-absences/shared/instances/leave-request.instance'\n], function (models) {\n  'use strict';\n\n  models.factory('LeaveRequest', [\n    '$log',\n    'Model',\n    'LeaveRequestAPI',\n    'LeaveRequestInstance',\n    function ($log, Model, leaveRequestAPI, instance) {\n      $log.debug('LeaveRequest');\n\n      return Model.extend({\n\n        /**\n         * Get all the Leave Requests.\n         * It supports filters, pagination, sort and extra params\n         *\n         * @param {object} filters - Values the full list should be filtered by\n         * @param {object} pagination\n         *   `page` for the current page, `size` for number of items per page\n         * @param {string} sort - The field and direction to order by\n         * @param  {Object} params\n         * @param  {Boolean} cache\n         * @return {Promise} resolves with {Object}\n         */\n        all: function (filters, pagination, sort, params, cache) {\n          return leaveRequestAPI.all(this.processFilters(filters), pagination, sort, params, cache)\n            .then(function (response) {\n              response.list = response.list.map(function (leaveRequest) {\n                return instance.init(leaveRequest, true);\n              });\n\n              return response;\n            });\n        },\n\n        /**\n         * Get all the total change in balance that is caused by the\n         * leave requests of a given absence type, or of all the absence types of a given contact and period.\n         *\n         * @param {string} contactId The ID of the Contact to get the balance change for\n         * @param {string} periodId The ID of the Absence Period to get the balance change for\n         * @param statuses {array} An array of OptionValue values which the list will be filtered by\n         * @param isPublicHoliday {boolean} Based on the value of this param,\n         * the calculation will include only the leave requests that aren't/are public holidays\n         * @return {Promise} Resolved with {Object} Balance Change data\n         */\n        balanceChangeByAbsenceType: function (contactId, periodId, statuses, isPublicHoliday) {\n          return leaveRequestAPI.balanceChangeByAbsenceType(contactId, periodId, statuses, isPublicHoliday);\n        },\n\n        /**\n         * Get leave request for the given id\n         *\n         * @param {object} id - leave request id\n         *\n         * @return {Promise} resolves with {Object}\n         */\n        find: function (id) {\n          return leaveRequestAPI.find(id)\n            .then(function (leaveRequest) {\n              return instance.init(leaveRequest, true);\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/leave-request.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/work-pattern.instance',[\n  'leave-absences/shared/modules/models-instances',\n  'common/models/instances/instance'\n], function (instances) {\n  'use strict';\n\n  instances.factory('WorkPatternInstance', ['$log', 'ModelInstance', function ($log, ModelInstance) {\n    $log.debug('WorkPatternInstance');\n\n    return ModelInstance.extend({});\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/work-pattern.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/work-pattern.model',[\n  'common/lodash',\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'leave-absences/shared/apis/work-pattern.api',\n  'leave-absences/shared/instances/work-pattern.instance'\n], function (_, models) {\n  'use strict';\n\n  models.factory('WorkPattern', [\n    '$log', 'Model', 'WorkPatternAPI', 'WorkPatternInstance',\n    function ($log, Model, workPatternAPI, instance) {\n      $log.debug('WorkPattern');\n\n      return Model.extend({\n\n        /**\n         * Assigns the given work pattern to the given contact id, also sets\n         * effective date, effective end date and change reason\n         *\n         * @param {string} contactId\n         * @param {string} workPatternID\n         * @param {string} effectiveDate\n         * @param {string} effectiveEndDate\n         * @param {string} changeReason\n         * @param {object} params - additional parameters\n         * @return {Promise}\n         */\n        assignWorkPattern: function (contactId, workPatternID, effectiveDate, effectiveEndDate, changeReason, params) {\n          return workPatternAPI.assignWorkPattern(contactId, workPatternID, effectiveDate, effectiveEndDate, changeReason, params);\n        },\n\n        /**\n         * Return the default work pattern\n         *\n         * @return {Promise}\n         */\n        default: function () {\n          return workPatternAPI.get({ default: true })\n            .then(function (defaultWorkPattern) {\n              return instance.init(defaultWorkPattern[0], true);\n            });\n        },\n\n        /**\n         * Unassign a work pattern by the given contact work pattern ID\n         *\n         * @param {string} contactWorkPatternID\n         * @return {Promise}\n         */\n        unassignWorkPattern: function (contactWorkPatternID) {\n          return workPatternAPI.unassignWorkPattern(contactWorkPatternID);\n        },\n\n        /**\n         * Returns the work patterns of the contact with the given id\n         *\n         * @param {string} contactId\n         * @param {object} params - additional parameters\n         * @param {boolean} cache\n         * @return {Promise}\n         */\n        workPatternsOf: function (contactId, params, cache) {\n          return workPatternAPI.workPatternsOf(contactId, params, cache)\n            .then(function (workPatterns) {\n              return workPatterns.map(function (workPattern) {\n                return instance.init(workPattern, true);\n              });\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/work-pattern.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/modules/components',[\n  'common/angular',\n  'common/modules/directives',\n  'common/modules/models',\n  './shared-settings',\n  './models'\n], function (angular) {\n  return angular.module('leave-absences.components', [\n    'common.directives',\n    'common.models',\n    'leave-absences.settings',\n    'leave-absences.models'\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/components.js"),eval("define('leave-absences/shared/modules/controllers',[\n  'common/angular',\n  'common/angularBootstrap',\n  'leave-absences/shared/modules/models',\n  'leave-absences/shared/modules/models-instances',\n  'leave-absences/shared/modules/shared-settings',\n], function (angular) {\n  return angular.module('leave-absences.controllers', [\n    'ui.select',\n    'leave-absences.models',\n    'leave-absences.models.instances',\n    'leave-absences.settings',\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/controllers.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/leave-calendar-admin.controller',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/controllers',\n  'common/models/contract',\n  'common/services/notification.service'\n], function (_, moment, controllers) {\n  controllers.controller('LeaveCalendarAdminController', ['$log', '$q',\n    'Contact', 'ContactInstance', 'Contract', 'notificationService', controller]);\n\n  function controller ($log, $q, Contact, ContactInstance, Contract, notification) {\n    $log.debug('LeaveCalendarAdminController');\n\n    var contracts, vm;\n\n    return {\n      /**\n       * Initializes the sub-controller, passing the context (and thus the interface)\n       * of the leave-calendar component's controller\n       */\n      init: function (_vm_) {\n        vm = _vm_;\n        vm.showContactName = true;\n        vm.showFilters = true;\n        vm.filtersByAssignee = [\n          { type: 'me', label: 'People I approve' },\n          { type: 'unassigned', label: 'People without approver' },\n          { type: 'all', label: 'All' }\n        ];\n        vm.filters.userSettings.assignedTo = vm.filtersByAssignee[0];\n\n        vm.showAdminFilteringHint = showAdminFilteringHint;\n\n        return api();\n      }\n    };\n\n    /**\n     * Get contact IDs filtered according to contracts that belong\n     * to the currently selected absence period\n     *\n     * @return {Promise} resolved to contacts list\n     */\n    function loadContactIdsToReduceTo () {\n      return loadContracts()\n      .then(function (contracts) {\n        var contractsInAbsencePeriod = contracts.filter(function (contract) {\n          var details = contract.info.details;\n\n          return (\n            moment(details.period_start_date).isSameOrBefore(vm.selectedPeriod.end_date) &&\n            (moment(details.period_end_date).isSameOrAfter(vm.selectedPeriod.start_date) ||\n              !details.period_end_date)\n          );\n        });\n\n        return _.uniq(contractsInAbsencePeriod.map(function (contract) {\n          return contract.contact_id;\n        }));\n      });\n    }\n\n    /**\n     * Returns the api of the sub-controller\n     *\n     * @return {Object}\n     */\n    function api () {\n      return {\n        /**\n         * Returns all contacts\n         *\n         * @return {Promise} resolves as an {Array}\n         */\n        loadContacts: function () {\n          var filterByAssignee = vm.filters.userSettings.assignedTo.type;\n\n          return lookupContacts(filterByAssignee)\n            .then(function (contacts) {\n              vm.lookupContacts = contacts;\n            })\n            .then(function () {\n              return (filterByAssignee !== 'me'\n                ? loadContactIdsToReduceTo() : $q.resolve(null));\n            })\n            .then(function (contactIdsToReduceTo) {\n              vm.contactIdsToReduceTo = contactIdsToReduceTo;\n\n              return loadContacts();\n            })\n            .then(function (contacts) {\n              return contacts;\n            });\n        }\n      };\n    }\n\n    /**\n     * Load all contacts with respect to filters\n     *\n     * @return {Promise}\n     */\n    function loadContacts () {\n      return Contact.all(prepareContactFilters(), null, 'display_name')\n        .then(function (contacts) {\n          return contacts.list;\n        });\n    }\n\n    /**\n     * Load all contracts or retrieve them from cache\n     *\n     * @return {Promise}\n     */\n    function loadContracts () {\n      return contracts ? $q.resolve(contracts) : Contract.all();\n    }\n\n    /**\n     * Returns the loading contacts promise depending on the\n     * filter by assignee chosen\n     *\n     * @param  {String} filterByAssignee (me|unassigned|all)\n     * @return {Promise} resolved to a list of loaded contacts\n     */\n    function lookupContacts (filterByAssignee) {\n      if (filterByAssignee === 'me') {\n        return Contact.leaveManagees(vm.contactId);\n      } else if (filterByAssignee === 'unassigned') {\n        return Contact.leaveManagees(undefined, {\n          unassigned: true\n        });\n      } else {\n        return Contact.all().then(function (contacts) {\n          return contacts.list;\n        });\n      }\n    }\n\n    /**\n     * Returns the filter object for contacts api\n     *\n     * @TODO This function should be a part of a Filter component, which is planned for future\n     *\n     * @return {Object}\n     */\n    function prepareContactFilters () {\n      return {\n        department: vm.filters.userSettings.department ? vm.filters.userSettings.department.value : null,\n        level_type: vm.filters.userSettings.level_type ? vm.filters.userSettings.level_type.value : null,\n        location: vm.filters.userSettings.location ? vm.filters.userSettings.location.value : null,\n        region: vm.filters.userSettings.region ? vm.filters.userSettings.region.value : null,\n        id: {\n          'IN': vm.filters.userSettings.contact\n            ? [vm.filters.userSettings.contact.id]\n            : vm.lookupContacts.map(function (contact) {\n              return contact.id;\n            })\n        }\n      };\n    }\n\n    /**\n     * Shows a hint to the filtering logic\n     */\n    function showAdminFilteringHint (comment) {\n      notification.info('', [\n        '<p>When <strong>All</strong> filter is selected, all staff members with contracts which are active in the selected absence period are displayed.</p>',\n        '<p><strong>People I approve</strong> filter displays only staff members who you approve leave for.</p>',\n        '<p><strong>People without approver</strong> filter displays all staff members with contracts which are active in the selected absence period and who do not have any leave approver assigned.</p>'\n      ].join(''));\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/leave-calendar-admin.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/leave-calendar-manager.controller',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/controllers'\n], function (_, moment, controllers) {\n  controllers.controller('LeaveCalendarManagerController', ['$log', 'Contact',\n    'ContactInstance', controller]);\n\n  function controller ($log, Contact, ContactInstance) {\n    $log.debug('LeaveCalendarManagerController');\n\n    var vm;\n\n    return {\n      /**\n       * Initializes the sub-controller, passing the context (and thus the interface)\n       * of the leave-calendar component's controller\n       */\n      init: function (_vm_) {\n        vm = _vm_;\n        vm.showContactName = true;\n        vm.showFilters = true;\n\n        return api();\n      }\n    };\n\n    /**\n     * Returns the api of the sub-controller\n     *\n     * @return {Object}\n     */\n    function api () {\n      return {\n        /**\n         * Returns the list of (filtered) contacts that the current contact manages\n         *\n         * @return {Promise} resolves as an {Array}\n         */\n        loadContacts: function () {\n          return ContactInstance.init({ id: vm.contactId })\n            .leaveManagees()\n            .then(function (contacts) {\n              vm.lookupContacts = contacts;\n            })\n            .then(loadContacts);\n        }\n      };\n    }\n\n    /**\n     * Load all contacts with respect to filters\n     *\n     * @return {Promise}\n     */\n    function loadContacts () {\n      return Contact.all(prepareContactFilters(), null, 'display_name')\n        .then(function (contacts) {\n          return contacts.list;\n        });\n    }\n\n    /**\n     * Returns the filter object for contacts api\n     *\n     * @TODO This function should be a part of a Filter component, which is planned for future\n     *\n     * @return {Object}\n     */\n    function prepareContactFilters () {\n      return {\n        department: vm.filters.userSettings.department ? vm.filters.userSettings.department.value : null,\n        level_type: vm.filters.userSettings.level_type ? vm.filters.userSettings.level_type.value : null,\n        location: vm.filters.userSettings.location ? vm.filters.userSettings.location.value : null,\n        region: vm.filters.userSettings.region ? vm.filters.userSettings.region.value : null,\n        id: {\n          'IN': vm.filters.userSettings.contact\n            ? [vm.filters.userSettings.contact.id]\n            : vm.lookupContacts.map(function (contact) {\n              return contact.id;\n            })\n        }\n      };\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/leave-calendar-manager.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/leave-calendar-staff.controller',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/controllers'\n], function (_, moment, controllers) {\n  controllers.controller('LeaveCalendarStaffController', ['$log', 'Contact', controller]);\n\n  function controller ($log, Contact) {\n    $log.debug('LeaveCalendarStaffController');\n\n    var vm;\n\n    return {\n      /**\n       * Initializes the sub-controller, passing the context (and thus the interface)\n       * of the leave-calendar component's controller\n       */\n      init: function (_vm_) {\n        vm = _vm_;\n        vm.filters.userSettings.contacts_with_leaves = false;\n\n        return api();\n      }\n    };\n\n    /**\n     * Returns the api of the sub-controller\n     *\n     * @return {Object}\n     */\n    function api () {\n      return {\n        /**\n         * Returns the data of the current contact\n         *\n         * It returns it as a single-item array to comply with the standard\n         * structure leave-calendar expect to receive the contacts as\n         *\n         * @return {Promise} resolves as an {Array}\n         */\n        loadContacts: function () {\n          return Contact.all({\n            id: { in: [vm.contactId] }\n          })\n          .then(function (contacts) {\n            return contacts.list;\n          });\n        }\n      };\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/leave-calendar-staff.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-calendar.component',[\n  'common/angular',\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'leave-absences/shared/controllers/sub-controllers/leave-calendar-admin.controller',\n  'leave-absences/shared/controllers/sub-controllers/leave-calendar-manager.controller',\n  'leave-absences/shared/controllers/sub-controllers/leave-calendar-staff.controller'\n], function (angular, _, moment, components) {\n  components.component('leaveCalendar', {\n    bindings: {\n      contactId: '<',\n      roleOverride: '@?'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-calendar.html';\n    }],\n    controllerAs: 'calendar',\n    controller: ['$controller', '$q', '$log', '$rootScope',\n      'shared-settings', 'AbsencePeriod', 'AbsenceType',\n      'PublicHoliday', 'OptionGroup', 'checkPermissions',\n      controller]\n  });\n\n  function controller ($controller, $q, $log, $rootScope, sharedSettings, AbsencePeriod, AbsenceType, PublicHoliday, OptionGroup, checkPermissions) {\n    $log.debug('Component: leave-calendar');\n\n    var subController, userRole;\n    var vm = this;\n\n    vm.absencePeriods = [];\n    vm.contacts = [];\n    vm.contactIdsToReduceTo = null;\n    vm.injectMonths = false;\n    vm.months = [];\n    vm.selectedMonths = null;\n    vm.selectedPeriod = null;\n    vm.showContactName = false;\n    vm.showFilters = false;\n    vm.supportData = {};\n    vm.loading = { calendar: true, page: true };\n    vm.filters = {\n      optionValues: {},\n      userSettings: {\n        contact: null,\n        contacts_with_leaves: true,\n        department: null,\n        level_type: null,\n        location: null,\n        region: null\n      }\n    };\n\n    vm.labelPeriod = labelPeriod;\n    vm.refresh = refresh;\n\n    (function init () {\n      setUserRole()\n      .then(initWatchers)\n      .then(injectSubController)\n      .then(makeSureMonthsAreNotInjected)\n      .then(loadAbsencePeriods)\n      .then(function () {\n        return $q.all([\n          loadContacts(),\n          loadSupportData()\n        ]);\n      })\n      .then(function () {\n        return vm.showFilters ? loadFiltersOptionValues() : _.noop;\n      })\n      .then(function () {\n        injectAndShowMonths();\n      })\n      .then(function () {\n        vm.loading.page = false;\n      });\n    }());\n\n    /**\n     * Creates a list of all the months in the currently selected period\n     */\n    function buildPeriodMonthsList () {\n      var months = [];\n      var pointerDate = moment(vm.selectedPeriod.start_date).clone().startOf('month');\n      var limitDate = moment(vm.selectedPeriod.end_date).clone().endOf('month');\n\n      while (pointerDate.isBefore(limitDate)) {\n        months.push(monthStructure(pointerDate));\n        pointerDate.add(1, 'month');\n      }\n\n      vm.months = months;\n    }\n\n    /**\n     * Initializes the scope properties' watchers\n     */\n    function initWatchers () {\n      $rootScope.$new().$watch(function () {\n        return vm.selectedMonths;\n      }, function (newValue, oldValue) {\n        if (oldValue !== null && !angular.equals(newValue, oldValue)) {\n          sendShowMonthsSignal();\n        }\n      });\n    }\n\n    /**\n     * Injects the leave-calendar-month components\n     * and sends the \"show months\" signal\n     *\n     * @param {Boolean} forceDataReload whether the months need to force data reload\n     */\n    function injectAndShowMonths (forceDataReload) {\n      vm.injectMonths = true;\n\n      waitUntilMonthsAre('injected').then(function () {\n        sendShowMonthsSignal(forceDataReload);\n      })\n      .then(function () {\n        vm.loading.calendar = false;\n      });\n    }\n\n    /**\n     * Injects the calendar sub controller specific for the role of the current user\n     */\n    function injectSubController () {\n      subController = $controller('LeaveCalendar' + _.capitalize(userRole) + 'Controller').init(vm);\n    }\n\n    /**\n     * Labels the given period according to whether it's current or not\n     *\n     * @param  {AbsencePeriodInstance} period\n     * @return {string}\n     */\n    function labelPeriod (period) {\n      return period.current ? 'Current Period (' + period.title + ')' : period.title;\n    }\n\n    /**\n     * Loads the absence periods\n     *\n     * @return {Promise}\n     */\n    function loadAbsencePeriods () {\n      return AbsencePeriod.all()\n        .then(function (absencePeriods) {\n          vm.absencePeriods = _.sortBy(absencePeriods, 'start_date');\n          vm.selectedPeriod = _.find(vm.absencePeriods, function (period) {\n            return !!period.current;\n          });\n        })\n        .then(buildPeriodMonthsList)\n        .then(setDefaultMonths);\n    }\n\n    /**\n     * Loads the active absence types\n     *\n     * @return {Promise}\n     */\n    function loadAbsenceTypes () {\n      return AbsenceType.all({ is_active: true });\n    }\n\n    /**\n     * Loads the OptionValues necessary for basic functioning of the controller\n     *\n     * @return {Promise}\n     */\n    function loadBasicOptionValues () {\n      return OptionGroup.valuesOf([\n        'hrleaveandabsences_leave_request_status',\n        'hrleaveandabsences_leave_request_day_type'\n      ]);\n    }\n\n    /**\n     * Loads the contacts by using the `loadContacts` method in the sub-controller\n     *\n     * @return {Promise}\n     */\n    function loadContacts () {\n      return subController.loadContacts().then(function (contacts) {\n        vm.contacts = contacts;\n      });\n    }\n\n    /**\n     * Loads the OptionValues necessary for the filters\n     *\n     * @return {Promise}\n     */\n    function loadFiltersOptionValues () {\n      return OptionGroup.valuesOf([\n        'hrjc_region',\n        'hrjc_location',\n        'hrjc_level_type',\n        'hrjc_department'\n      ])\n      .then(function (data) {\n        vm.filters.optionValues.regions = data.hrjc_region;\n        vm.filters.optionValues.locations = data.hrjc_location;\n        vm.filters.optionValues.levelTypes = data.hrjc_level_type;\n        vm.filters.optionValues.departments = data.hrjc_department;\n      });\n    }\n\n    /**\n     * Loads all the public holidays\n     *\n     * @return {Promise}\n     */\n    function loadPublicHolidays () {\n      return PublicHoliday.all();\n    }\n\n    /**\n     * Loads all the data needed for the child components\n     *\n     * @return {Promise}\n     */\n    function loadSupportData () {\n      return $q.all([\n        loadAbsenceTypes(),\n        loadPublicHolidays(),\n        loadBasicOptionValues()\n      ])\n      .then(function (results) {\n        vm.supportData.absenceTypes = results[0];\n        vm.supportData.publicHolidays = results[1];\n        vm.supportData.leaveRequestStatuses = results[2].hrleaveandabsences_leave_request_status;\n        vm.supportData.dayTypes = results[2].hrleaveandabsences_leave_request_day_type;\n      });\n    }\n\n    /**\n     * If the months are already injected, it removes then and then wait\n     * for their components to confirme that they are destroyed\n     *\n     * @return {Promise}\n     */\n    function makeSureMonthsAreNotInjected () {\n      var promise = $q.resolve();\n\n      if (vm.injectMonths) {\n        promise = waitUntilMonthsAre('destroyed');\n        vm.injectMonths = false;\n      }\n\n      return promise;\n    }\n\n    /**\n     * Returns the structure of the month of the given date\n     *\n     * @param  {Moment} dateMoment\n     * @return {Object}\n     */\n    function monthStructure (dateMoment) {\n      return {\n        index: dateMoment.month(),\n        year: dateMoment.year(),\n        name: dateMoment.format('MMMM'),\n        shortName: dateMoment.format('MMM')\n      };\n    }\n\n    /**\n     * Reloads the selected months data\n     *\n     * If the source of the refresh is a period change, then\n     * it rebuilds the months list as well\n     * If the source of the refresh is a change in contacts filters, then\n     * it reloads the contacts as well\n     *\n     * @param {string} source The source of the refresh (period or contacts change)\n     */\n    function refresh (source) {\n      source = _.includes(['contacts', 'period'], source) ? source : 'period';\n\n      $q.resolve()\n        .then(function () {\n          vm.loading.calendar = true;\n        })\n        .then(makeSureMonthsAreNotInjected)\n        .then(source === 'period' ? buildPeriodMonthsList : _.noop)\n        .then(source === 'contacts' ? loadContacts : _.noop)\n        .then(function () {\n          injectAndShowMonths((source === 'contacts'));\n        });\n    }\n\n    /**\n     * Sends the \"show\" signal to the leave-calendar-month components\n     *\n     * @param {Boolean} forceDataReload if true, then a month will load its data\n     *   regardless if it had already loaded it\n     */\n    function sendShowMonthsSignal (forceDataReload) {\n      var monthsToShow = !vm.selectedMonths.length\n        ? vm.months\n        : vm.months.filter(function (month) {\n          return _.includes(vm.selectedMonths, month.index);\n        });\n\n      $rootScope.$emit('LeaveCalendar::showMonths', monthsToShow, !!forceDataReload);\n    }\n\n    /**\n     * Sets the months that are to be selected by default\n     */\n    function setDefaultMonths () {\n      vm.selectedMonths = [moment().month()];\n    }\n\n    /**\n     * Sets the user's role based on his permissions\n     *\n     * @return {Promise}\n     */\n    function setUserRole () {\n      if (vm.roleOverride) {\n        return $q.resolve().then(function () {\n          userRole = vm.roleOverride;\n        });\n      } else {\n        return $q.all([\n          checkPermissions(sharedSettings.permissions.admin.administer),\n          checkPermissions(sharedSettings.permissions.ssp.manage)\n        ])\n        .then(function (results) {\n          userRole = results[0] ? 'admin' : (results[1] ? 'manager' : 'staff');\n        });\n      }\n    }\n\n    /**\n     * Waits until all leave-calendar-month components are <some status>\n     *\n     * @return {Promise}\n     */\n    function waitUntilMonthsAre (status) {\n      return $q(function (resolve) {\n        var monthLoadedCounter = 0;\n        var removeListener = $rootScope.$on('LeaveCalendar::month' + _.capitalize(status), function () {\n          if (++monthLoadedCounter === vm.months.length) {\n            removeListener();\n            resolve();\n          }\n        });\n      });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-calendar.component.js"),
eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-calendar-day.component',[\n  'leave-absences/shared/modules/components'\n], function (components) {\n  components.component('leaveCalendarDay', {\n    bindings: { contactData: '<' },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-calendar-day.html';\n    }],\n    controllerAs: 'day',\n    controller: LeaveCalendarDayController\n  });\n\n  LeaveCalendarDayController.$inject = ['$log', 'LeavePopup'];\n\n  function LeaveCalendarDayController ($log, LeavePopup) {\n    'use strict';\n    $log.debug('Component: leave-calendar-day');\n\n    var vm = this;\n\n    vm.openLeavePopup = openLeavePopup;\n\n    /**\n     * Opens the leave request popup\n     *\n     * When leave-request-actions.component sits inside manage-request component's table rows,\n     * and the table row has a click event to open leave request, so event.stopPropagation()\n     * is necessary to prevent the parents click event from being called\n     *\n     * @param {Object} event\n     * @param {Object} leaveRequest\n     * @param {String} leaveType\n     * @param {String} selectedContactId\n     * @param {Boolean} isSelfRecord\n     */\n    function openLeavePopup (event, leaveRequest, leaveType, selectedContactId, isSelfRecord) {\n      event.stopPropagation();\n      LeavePopup.openModal(leaveRequest, leaveType, selectedContactId, isSelfRecord);\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-calendar-day.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-calendar-legend.component',[\n  'leave-absences/shared/modules/components'\n], function (components) {\n  components.component('leaveCalendarLegend', {\n    bindings: {\n      absenceTypes: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-calendar-legend.html';\n    }],\n    controllerAs: 'legend',\n    controller: ['$log', controller]\n  });\n\n  function controller ($log) {\n    $log.debug('Component: leave-calendar-legend');\n\n    var vm = this;\n    vm.legendCollapsed = true;\n\n    vm.getAbsenceTypeStyle = getAbsenceTypeStyle;\n\n    /**\n     * Uses the absence type color to return border and background color styles\n     *\n     * @param  {AbsenceTypeInstance} absenceType\n     * @return {Object}\n     */\n    function getAbsenceTypeStyle (absenceType) {\n      return {\n        backgroundColor: absenceType.color,\n        borderColor: absenceType.color\n      };\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-calendar-legend.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-calendar-month.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/services/pub-sub'\n], function (_, moment, components) {\n  components.component('leaveCalendarMonth', {\n    bindings: {\n      contacts: '<',\n      contactIdsToReduceTo: '<',\n      month: '<',\n      period: '<',\n      showContactName: '<',\n      showOnlyWithLeaveRequests: '<',\n      supportData: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-calendar-month.html';\n    }],\n    controllerAs: 'month',\n    controller: ['$log', '$q', '$rootScope', 'Calendar', 'LeaveRequest',\n      'pubSub', 'shared-settings', controller]\n  });\n\n  function controller ($log, $q, $rootScope, Calendar, LeaveRequest, pubSub,\n    sharedSettings) {\n    $log.debug('Component: leave-calendar-month');\n\n    var dataLoaded = false;\n    var eventListeners = [];\n    var calendars = {};\n    var leaveRequests = {};\n    var vm = this;\n\n    vm.currentPage = 0;\n    vm.pageSize = 20;\n    vm.visible = false;\n    vm.showContactName = !!vm.showContactName;\n    vm.showOnlyWithLeaveRequests = !!vm.showOnlyWithLeaveRequests;\n\n    vm.$onDestroy = onDestroy;\n    vm.contactsList = contactsList;\n\n    (function init () {\n      var dateFromMonth = moment().month(vm.month.index).year(vm.month.year);\n\n      indexData();\n      initListeners();\n\n      vm.month = buildMonthStructure(dateFromMonth);\n\n      $rootScope.$emit('LeaveCalendar::monthInjected');\n    }());\n\n    /**\n     * Adds a leave request to the calendar\n     *\n     * @param {LeaveRequestInstance} leaveRequest\n     */\n    function addLeaveRequest (leaveRequest) {\n      indexLeaveRequests([leaveRequest]);\n      updateLeaveRequestDaysContactData(leaveRequest);\n    }\n\n    /**\n     * Returns the structure of the month of the given date\n     *\n     * @param  {Moment} dateMoment\n     * @return {Object}\n     */\n    function buildMonthStructure (dateMoment) {\n      return {\n        index: dateMoment.month(),\n        year: dateMoment.year(),\n        name: dateMoment.format('MMMM'),\n        loading: true,\n        days: buildMonthDaysStructure(dateMoment)\n      };\n    }\n\n    /**\n     * Returns the structure of the days list of the month of the given date\n     *\n     * @param  {Moment} dateMoment\n     * @return {Object}\n     */\n    function buildMonthDaysStructure (dateMoment) {\n      var today = moment();\n      var pointerDay = dateMoment.clone().startOf('month');\n\n      return _.map(_.times(dateMoment.daysInMonth()), function () {\n        var dayObj = {\n          date: pointerDay.format('YYYY-MM-DD'),\n          name: pointerDay.format('ddd'),\n          index: pointerDay.format('D'),\n          current: today.isSame(pointerDay, 'day'),\n          enabled: pointerDay.isSameOrAfter(vm.period.start_date) &&\n            pointerDay.isSameOrBefore(vm.period.end_date),\n          contactsData: {}\n        };\n\n        pointerDay.add(1, 'day');\n\n        return dayObj;\n      });\n    }\n\n    /**\n     * Returns work pattern calendar of the given contact\n     *\n     * @param  {String} contactId\n     * @return {Object}\n     */\n    function contactMonthWorkPatternCalendar (contactId) {\n      return calendars[contactId];\n    }\n\n    /**\n     * Gives the list of contacts to display, eventually filtered\n     *\n     * @return {Array}\n     */\n    function contactsList () {\n      return !vm.showOnlyWithLeaveRequests ? vm.contacts : vm.contacts.filter(function (contact) {\n        return _.includes(Object.keys(leaveRequests), contact.id);\n      });\n    }\n\n    /**\n     * Converts given date to moment object with server format\n     *\n     * @param {Date/String} date from server\n     * @return {Moment}\n     */\n    function dateObjectWithFormat (date) {\n      return moment(date, sharedSettings.serverDateFormat);\n    }\n\n    /**\n     * Deletes the given leave request from the list\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     */\n    function deleteLeaveRequest (leaveRequest) {\n      removeLeaveRequestFromIndexedList(leaveRequest);\n      updateLeaveRequestDaysContactData(leaveRequest);\n    }\n\n    /**\n     * If there are contacts to reduce to, reduces contacts to the list provided,\n     * plus leaves those who have leave requests at the given month period\n     *\n     * @return {Promise}\n     */\n    function reduceContacts () {\n      if (vm.contactIdsToReduceTo) {\n        vm.contacts = vm.contacts.filter(function (contact) {\n          return (_.includes(vm.contactIdsToReduceTo, contact.contact_id) ||\n            _.find(leaveRequests, function (leaveRequest) {\n              return leaveRequest.contact_id === contact.contact_id;\n            }));\n        });\n      }\n\n      return $q.resolve();\n    }\n\n    /**\n     * Indexes for easy access the data that the component needs\n     */\n    function indexData () {\n      vm.supportData.dayTypes = _.indexBy(vm.supportData.dayTypes, 'name');\n      vm.supportData.leaveRequestStatuses = _.indexBy(vm.supportData.leaveRequestStatuses, 'value');\n      vm.supportData.publicHolidays = _.transform(vm.supportData.publicHolidays, function (result, publicHoliday) {\n        result[dateObjectWithFormat(publicHoliday.date).valueOf()] = publicHoliday;\n      }, {});\n    }\n\n    /**\n     * Index leave requests by contact_id as first level\n     * and date as second level\n     *\n     * @param  {Array} leaveRequestsList\n     * @return {Promise}\n     */\n    function indexLeaveRequests (leaveRequestsList) {\n      leaveRequestsList.forEach(function (leaveRequest) {\n        var days = leaveRequestDays(leaveRequest);\n\n        leaveRequests[leaveRequest.contact_id] = leaveRequests[leaveRequest.contact_id] || {};\n\n        days.forEach(function (day) {\n          leaveRequests[leaveRequest.contact_id][day.date] = leaveRequest;\n        });\n      });\n\n      return $q.resolve();\n    }\n\n    /**\n     * Initializes the event listeners\n     */\n    function initListeners () {\n      eventListeners.push($rootScope.$on('LeaveCalendar::showMonths', showMonthIfInList));\n      eventListeners.push(pubSub.subscribe('LeaveRequest::new', addLeaveRequest));\n      eventListeners.push(pubSub.subscribe('LeaveRequest::edit', updateLeaveRequest));\n      eventListeners.push(pubSub.subscribe('LeaveRequest::updatedByManager', updateLeaveRequest));\n      eventListeners.push(pubSub.subscribe('LeaveRequest::deleted', deleteLeaveRequest));\n    }\n\n    /**\n     * Returns whether a date is of a specific type\n     * half_day_am or half_day_pm\n     *\n     * @param  {String} typeName\n     * @param  {object} leaveRequest\n     * @param  {String} date\n     *\n     * @return {boolean}\n     */\n    function isDayType (typeName, leaveRequest, date) {\n      var dayType = vm.supportData.dayTypes[typeName];\n\n      if (moment(date).isSame(leaveRequest.from_date)) {\n        return dayType.value === leaveRequest.from_date_type;\n      }\n\n      if (moment(date).isSame(leaveRequest.to_date)) {\n        return dayType.value === leaveRequest.to_date_type;\n      }\n    }\n\n    /**\n     * Returns whether a leaveRequest is of the sent leave type\n     *\n     * @param  {object} leaveRequest\n     * @param  {String} leaveType\n     * @return {boolean}\n     */\n    function isLeaveType (leaveRequest, leaveType) {\n      return leaveRequest.request_type === leaveType;\n    }\n\n    /**\n     * Checks whether sent date is a public holiday\n     *\n     * @param  {String} date\n     * @return {boolean}\n     */\n    function isPublicHoliday (date) {\n      return !!vm.supportData.publicHolidays[dateObjectWithFormat(date).valueOf()];\n    }\n\n    /**\n     * Checks whether a leaveRequest is pending approval or more information requested\n     *\n     * @param  {object} leaveRequest\n     * @return {boolean}\n     */\n    function isRequested (leaveRequest) {\n      var statusName = vm.supportData.leaveRequestStatuses[leaveRequest.status_id].name;\n\n      return _.contains([\n        sharedSettings.statusNames.awaitingApproval,\n        sharedSettings.statusNames.moreInformationRequired\n      ], statusName);\n    }\n\n    /**\n     * Returns the list of day objects corresponding to the dates the\n     * given leave request spans\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     * @return {Array}\n     */\n    function leaveRequestDays (leaveRequest) {\n      var days = [];\n      var pointerDate = moment(leaveRequest.from_date).clone();\n      var toDate = moment(leaveRequest.to_date);\n\n      while (pointerDate.isSameOrBefore(toDate)) {\n        // Ensure that pointerDate is in same month/year that component represents\n        if (pointerDate.month() === vm.month.index && pointerDate.year() === vm.month.year) {\n          days.push(_.find(vm.month.days, function (day) {\n            return day.date === pointerDate.format('YYYY-MM-DD');\n          }));\n        }\n\n        pointerDate.add(1, 'day');\n      }\n\n      return days;\n    }\n\n    /**\n     * Finds the given leave request in the internal indexed list\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     * @return {LeaveRequestInstance}\n     */\n    function leaveRequestFromIndexedList (leaveRequest) {\n      return _.find(leaveRequests[leaveRequest.contact_id], function (leaveRequestObj) {\n        return leaveRequest.id === leaveRequestObj.id;\n      });\n    }\n\n    /**\n     * Returns leave status value from name\n     *\n     * @param {String} name - name of the leave status\n     * @returns {int/null}\n     */\n    function leaveRequestStatusValueFromName (name) {\n      var leaveStatus = _.find(vm.supportData.leaveRequestStatuses, function (status) {\n        return status.name === name;\n      });\n\n      return leaveStatus ? leaveStatus.value : null;\n    }\n\n    /**\n     * Loads the work pattern calendar and the leave request of the month,\n     * then it process the data onto each day of the month\n     *\n     * @return {Promise}\n     */\n    function loadMonthData () {\n      vm.month.loading = true;\n\n      return $q.all([\n        loadMonthWorkPatternCalendars(),\n        loadMonthLeaveRequests()\n      ])\n      .then(reduceContacts)\n      .then(setMonthDaysContactData)\n      .then(function () {\n        dataLoaded = true;\n      })\n      .then(function () {\n        vm.month.loading = false;\n      });\n    }\n\n    /**\n     * Loads the approved/pending leave requests of the month, limited\n     * to the calendar contacts. It then indexes the leave requests\n     *\n     * @return {Promise}\n     */\n    function loadMonthLeaveRequests () {\n      return LeaveRequest.all({\n        from_date: { to: vm.month.days[vm.month.days.length - 1].date },\n        to_date: { from: vm.month.days[0].date },\n        status_id: {'IN': [\n          leaveRequestStatusValueFromName(sharedSettings.statusNames.approved),\n          leaveRequestStatusValueFromName(sharedSettings.statusNames.adminApproved),\n          leaveRequestStatusValueFromName(sharedSettings.statusNames.awaitingApproval),\n          leaveRequestStatusValueFromName(sharedSettings.statusNames.moreInformationRequired)\n        ]},\n        contact_id: { 'IN': vm.contacts.map(function (contact) {\n          return contact.id;\n        })}\n      }, null, null, null, false)\n      .then(function (leaveRequestsData) {\n        return indexLeaveRequests(leaveRequestsData.list);\n      });\n    }\n\n    /**\n     * Loads the month's calendar of each contact\n     *\n     * @return {Promise}\n     */\n    function loadMonthWorkPatternCalendars () {\n      var monthStartDate = vm.month.days[0].date;\n      var monthEndDate = vm.month.days[vm.month.days.length - 1].date;\n\n      return Calendar.get(vm.contacts.map(function (contact) {\n        return contact.id;\n      }), monthStartDate, monthEndDate)\n      .then(function (monthCalendars) {\n        calendars = _.indexBy(monthCalendars, 'contact_id');\n      });\n    }\n\n    /**\n     * Removes the given leave request from the internal indexed list\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     */\n    function removeLeaveRequestFromIndexedList (leaveRequest) {\n      leaveRequests[leaveRequest.contact_id] = _.omit(\n        leaveRequests[leaveRequest.contact_id],\n        function (leaveRequestObj) {\n          return leaveRequestObj.id === leaveRequest.id;\n        }\n      );\n    }\n\n    /**\n     * Event handler for when the component is destroyed\n     */\n    function onDestroy () {\n      $rootScope.$emit('LeaveCalendar::monthDestroyed');\n\n      eventListeners.map(function (destroyListener) {\n        destroyListener.remove\n          ? destroyListener.remove() // Destroy pubSub subscription\n          : destroyListener(); // Destroy $scope.$on subscription\n      });\n    }\n\n    /**\n     * Sets the properties of the given day, for the contact with the given id\n     *\n     * @param {Object} day\n     * @param {String} contactId\n     * @param {Boolean} leaveRequestPropertiesOnly updates only properties\n     *   related to the contact's leave request on the day (if any)\n     */\n    function setDayContactData (day, contactId, leaveRequestPropertiesOnly) {\n      var promise, workPatternCalendar;\n\n      day.contactsData[contactId] = day.contactsData[contactId] || {};\n\n      workPatternCalendar = contactMonthWorkPatternCalendar(contactId);\n\n      promise = (leaveRequestPropertiesOnly === true) ? $q.resolve() : $q.all([\n        workPatternCalendar.isWeekend(dateObjectWithFormat(day.date)),\n        workPatternCalendar.isNonWorkingDay(dateObjectWithFormat(day.date))\n      ])\n      .then(function (results) {\n        _.assign(day.contactsData[contactId], {\n          isWeekend: results[0],\n          isNonWorkingDay: results[1],\n          isPublicHoliday: isPublicHoliday(day.date)\n        });\n      });\n\n      return promise.then(function () {\n        return leaveRequests[contactId] ? leaveRequests[contactId][day.date] : null;\n      })\n      .then(function (leaveRequest) {\n        _.assign(day.contactsData[contactId], {\n          leaveRequest: leaveRequest || null,\n          styles: leaveRequest ? styles(leaveRequest) : null,\n          isAccruedTOIL: leaveRequest ? isLeaveType(leaveRequest, 'toil') : null,\n          isRequested: leaveRequest ? isRequested(leaveRequest) : null,\n          isAM: leaveRequest ? isDayType('half_day_am', leaveRequest, day.date) : null,\n          isPM: leaveRequest ? isDayType('half_day_pm', leaveRequest, day.date) : null\n        });\n      });\n    }\n\n    /**\n     * It sets the properties of every day of the month\n     *\n     * @return {Promise}\n     */\n    function setMonthDaysContactData () {\n      return $q.all(vm.month.days.map(function (day) {\n        return $q.all(vm.contacts.map(function (contact) {\n          return setDayContactData(day, contact.id);\n        }));\n      }));\n    }\n\n    /**\n     * Show the month and its data if it's included in the given list\n     *\n     * @param  {Array} monthsToShow\n     * @param  {Boolean} forceReload If true it forces the reload of the data\n     */\n    function showMonthIfInList (__, monthsToShow, forceReload) {\n      var isIncluded = !!_.find(monthsToShow, function (month) {\n        return month.index === vm.month.index;\n      });\n\n      if (isIncluded) {\n        vm.currentPage = 0;\n        vm.visible = true;\n\n        (forceReload || !dataLoaded) && loadMonthData();\n      } else {\n        vm.visible = false;\n      }\n    }\n\n    /**\n     * Returns the styles for a specific leaveRequest\n     * which will be used in the view for each date\n     *\n     * @param  {Object} leaveRequest\n     * @return {Object}\n     */\n    function styles (leaveRequest) {\n      var absenceType = _.find(vm.supportData.absenceTypes, function (absenceType) {\n        return absenceType.id === leaveRequest.type_id;\n      });\n\n      return leaveRequest.balance_change > 0\n        ? { borderColor: absenceType.color }\n        : { borderColor: absenceType.color, backgroundColor: absenceType.color };\n    }\n\n    /**\n     * Updates the given leave request in the calendar\n     * For simplicity's sake, it directly deletes it and re-adds it\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     */\n    function updateLeaveRequest (leaveRequest) {\n      var oldLeaveRequest = leaveRequestFromIndexedList(leaveRequest);\n\n      deleteLeaveRequest(oldLeaveRequest);\n      addLeaveRequest(leaveRequest);\n    }\n\n    /**\n     * Updates the properties of the days that the given leave request spans\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     * @return {Promise}\n     */\n    function updateLeaveRequestDaysContactData (leaveRequest) {\n      return $q.all(leaveRequestDays(leaveRequest).map(function (day) {\n        return setDayContactData(day, leaveRequest.contact_id, true);\n      }));\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-calendar-month.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-request-actions.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/services/hr-settings',\n  'common/services/notification.service',\n  'common/services/pub-sub'\n], function (_, moment, components) {\n  components.component('leaveRequestActions', {\n    bindings: {\n      leaveRequest: '<',\n      leaveRequestStatuses: '<',\n      absenceTypes: '<',\n      /**\n       * Role is not a permission level in this case.\n       * For example Manager can act as Staff\n       * and Admin can act as either Manager or Staff.\n       */\n      role: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-request-actions.html';\n    }],\n    controllerAs: 'actions',\n    controller: LeaveRequestActionsController\n  });\n\n  LeaveRequestActionsController.$inject = ['$log', '$rootScope', 'dialog',\n    'LeavePopup', 'pubSub', 'shared-settings', 'notificationService'];\n\n  function LeaveRequestActionsController ($log, $rootScope, dialog,\n    LeavePopup, pubSub, sharedSettings, notification) {\n    $log.debug('Component: leave-request-action-dropdown');\n\n    var vm = this;\n    var statusIdBeforeAction;\n    var statusNames = sharedSettings.statusNames;\n    var actions = {\n      edit: {\n        label: 'Edit',\n        allowedStatuses: [statusNames.awaitingApproval]\n      },\n      respond: {\n        label: 'Respond',\n        allowedStatuses: [statusNames.moreInformationRequired]\n      },\n      view: {\n        label: 'View',\n        allowedStatuses: [\n          statusNames.approved,\n          statusNames.rejected,\n          statusNames.cancelled\n        ]\n      },\n      approve: {\n        label: 'Approve',\n        isDirectAction: true,\n        allowedStatuses: [statusNames.awaitingApproval],\n        dialog: {\n          title: 'Approval',\n          btnClass: 'success',\n          btnLabel: 'Approve',\n          msg: 'Please confirm approval'\n        }\n      },\n      reject: {\n        label: 'Reject',\n        isDirectAction: true,\n        allowedStatuses: [statusNames.awaitingApproval],\n        dialog: {\n          title: 'Rejection',\n          btnClass: 'warning',\n          btnLabel: 'Reject',\n          msg: 'Please confirm rejection'\n        }\n      },\n      cancel: {\n        label: 'Cancel',\n        isDirectAction: true,\n        allowedStatuses: [\n          statusNames.awaitingApproval,\n          statusNames.approved,\n          statusNames.rejected,\n          statusNames.moreInformationRequired\n        ],\n        dialog: {\n          title: 'Cancellation',\n          btnClass: 'danger',\n          btnLabel: 'Confirm',\n          msg: 'Please confirm cancellation'\n        }\n      },\n      delete: {\n        label: 'Delete',\n        isDirectAction: true,\n        allowedStatuses: [\n          statusNames.awaitingApproval,\n          statusNames.moreInformationRequired,\n          statusNames.approved,\n          statusNames.rejected,\n          statusNames.cancelled\n        ],\n        dialog: {\n          title: 'Deletion',\n          btnClass: 'danger',\n          btnLabel: 'Confirm',\n          msg: 'This cannot be undone'\n        }\n      }\n    };\n\n    vm.allowedActions = [];\n\n    vm.action = action;\n    vm.openLeavePopup = openLeavePopup;\n\n    (function init () {\n      indexSupportData();\n      setAllowedActions();\n    }());\n\n    /**\n     * Performs an action on a given leave request\n     *\n     * @param {string} action\n     */\n    function action (action) {\n      var dialogParams = actions[action].dialog;\n\n      statusIdBeforeAction = vm.leaveRequest.status_id;\n\n      dialog.open({\n        title: 'Confirm ' + dialogParams.title + '?',\n        copyCancel: 'Cancel',\n        copyConfirm: dialogParams.btnLabel,\n        classConfirm: 'btn-' + dialogParams.btnClass,\n        msg: dialogParams.msg,\n        onConfirm: function () {\n          return vm.leaveRequest[action]()\n            .then(function () {\n              publishEvents(action);\n            })\n            .catch(function (error) {\n              notification.error('Error:', error);\n            });\n        }\n      });\n    }\n\n    /**\n     * Checks if the given leave request can be cancelled\n     *\n     * @TODO This function utilises external resource\n     * vm.absenceTypes - this sould be refactored\n     *\n     * @return {Boolean}\n     */\n    function canLeaveRequestBeCancelled (leaveRequestStatus) {\n      var allowCancellationValue = vm.absenceTypes[vm.leaveRequest.type_id].allow_request_cancelation;\n\n      // Admin can always cancel\n      if (vm.role === 'admin') {\n        return true;\n      }\n\n      // Others but Admin can cancel if only the leave request status is\n      // either \"Awaiting for Approval\" or \"More Information Required\"\n      if (!_.includes([statusNames.awaitingApproval, statusNames.moreInformationRequired],\n        leaveRequestStatus)) {\n        return false;\n      }\n\n      // Manager can cancel disregarding the allow_request_cancelation value\n      if (vm.role === 'manager') {\n        return true;\n      }\n\n      // If request can only be cancelled in advance of start date\n      if (allowCancellationValue === '3') {\n        return moment().isBefore(vm.leaveRequest.from_date);\n      }\n\n      // If request can always be cancelled\n      return allowCancellationValue === '2';\n    }\n\n    /**\n     * Indexes leave request statuses and absence types\n     * if they are passed as arrays to the component\n     */\n    function indexSupportData () {\n      if (_.isArray(vm.leaveRequestStatuses)) {\n        vm.leaveRequestStatuses = _.indexBy(vm.leaveRequestStatuses, 'value');\n      }\n\n      if (_.isArray(vm.absenceTypes)) {\n        vm.absenceTypes = _.indexBy(vm.absenceTypes, 'id');\n      }\n    }\n\n    /**\n     * Opens the leave request popup\n     *\n     * When the component appears inside other elements\n     * which also having click events, event.stopPropagation() is necessary\n     * to prevent the click events of parent elements from being called\n     *\n     * @param {Object} event\n     * @param {Object} leaveRequest\n     * @param {String} leaveType\n     * @param {String} selectedContactId\n     * @param {Boolean} isSelfRecord\n     */\n    function openLeavePopup (event, leaveRequest, leaveType, selectedContactId, isSelfRecord) {\n      event.stopPropagation();\n      LeavePopup.openModal(leaveRequest, leaveType, selectedContactId, isSelfRecord);\n    }\n\n    /**\n     * Publish events\n     *\n     * @param {String} action\n     */\n    function publishEvents (action) {\n      var awaitingApprovalStatusValue = _.find(vm.leaveRequestStatuses, function (status) {\n        return status.name === sharedSettings.statusNames.awaitingApproval;\n      }).value;\n\n      // Check if the status was \"Awaiting Approval\" before the action\n      if (statusIdBeforeAction === awaitingApprovalStatusValue) {\n        pubSub.publish('ManagerBadge:: Update Count');\n      }\n\n      pubSub.publish('LeaveRequest::' + (action === 'delete' ? 'deleted' : 'edit'),\n        vm.leaveRequest);\n    }\n\n    /**\n     * @TODO This function utilises external resources:\n     * vm.leaveRequestStatuses - this sould be refactored\n     *\n     * Sets actions that can be performed within the\n     * leave request basing on its status and user role\n     *\n     */\n    function setAllowedActions () {\n      var leaveRequestStatus = vm.leaveRequestStatuses[vm.leaveRequest.status_id].name;\n      var allowedActions = _.compact(_.map(actions, function (action, actionKey) {\n        return _.includes(action.allowedStatuses, leaveRequestStatus) ? actionKey : null;\n      }));\n\n      (!canLeaveRequestBeCancelled(leaveRequestStatus)) && _.pull(allowedActions, 'cancel');\n      (vm.role !== 'admin') && _.pull(allowedActions, 'delete');\n      (vm.role === 'staff') && _.pull(allowedActions, 'approve', 'reject');\n      (vm.role !== 'staff') && swapViewEditAndRespondActions(allowedActions);\n\n      vm.allowedActions = _.map(allowedActions, function (action) {\n        return {\n          key: action,\n          label: actions[action].label,\n          isDirectAction: actions[action].isDirectAction\n        };\n      });\n    }\n\n    /**\n     * Swaps Edit and Respond actions in allowed actions list\n     *\n     * @param {Array} actions\n     */\n    function swapViewEditAndRespondActions (actions) {\n      _.each(actions, function (action, actionKey) {\n        (action === 'edit') && (actions[actionKey] = 'respond');\n        (_.includes(['respond', 'view'], action)) && (actions[actionKey] = 'edit');\n      });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-request-actions.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-request-popup-comments-tab.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/services/hr-settings',\n  'common/models/session.model'\n], function (_, moment, components) {\n  components.component('leaveRequestPopupCommentsTab', {\n    bindings: {\n      canManage: '<',\n      mode: '<',\n      request: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-request-popup/leave-request-popup-comments-tab.html';\n    }],\n    controllerAs: 'commentsCtrl',\n    controller: ['$log', '$rootScope', 'HR_settings', 'shared-settings', 'Contact', 'Session', controller]\n  });\n\n  function controller ($log, $rootScope, HRSettings, sharedSettings, Contact, Session) {\n    $log.debug('Component: leave-request-popup-comments-tab');\n\n    var loggedInContactId = null;\n    var vm = this;\n\n    vm.loading = { component: true };\n    vm.comment = {\n      text: '',\n      contacts: {}\n    };\n\n    (function init () {\n      loadCommentsAndContactNames();\n      loadLoggedInContactId();\n    }());\n\n    /**\n     * Add a comment into comments array, also clears the comments textbox\n     */\n    vm.addComment = function () {\n      vm.request.comments.push({\n        contact_id: loggedInContactId,\n        leave_request_id: vm.request.id,\n        text: vm.comment.text\n      });\n      vm.comment.text = '';\n    };\n\n    /**\n     * Format a date-time into user format and returns\n     *\n     * @return {String}\n     */\n    vm.formatDateTime = function (dateTime) {\n      return moment.utc(dateTime, sharedSettings.serverDateTimeFormat).local().format(HRSettings.DATE_FORMAT.toUpperCase() + ' HH:mm');\n    };\n\n    /**\n     * Returns the comments which are not marked for deletion\n     *\n     * @return {Array}\n     */\n    vm.getActiveComments = function () {\n      return vm.request.comments.filter(function (comment) {\n        return !comment.toBeDeleted;\n      });\n    };\n\n    /**\n     * Returns the comment author name\n     * @param {String} contactId\n     *\n     * @return {String}\n     */\n    vm.getCommentorName = function (contactId) {\n      if (contactId === loggedInContactId) {\n        return 'Me';\n      } else if (vm.comment.contacts[contactId]) {\n        return vm.comment.contacts[contactId].display_name;\n      }\n    };\n\n    /**\n     * Checks if popup is opened in given mode\n     *\n     * @param {String} modeParam to open leave request like edit or view or create\n     * @return {Boolean}\n     */\n    vm.isMode = function (modeParam) {\n      return vm.mode === modeParam;\n    };\n\n    /**\n     * Orders comment, used as a angular filter\n     * @param {Object} comment\n     *\n     * @return {Date}\n     */\n    vm.orderComment = function (comment) {\n      return moment(comment.created_at, sharedSettings.serverDateTimeFormat);\n    };\n\n    /**\n     * Decides visiblity of remove comment button\n     * @param {Object} comment - comment object\n     *\n     * @return {Boolean}\n     */\n    vm.removeCommentVisibility = function (comment) {\n      return !comment.comment_id || vm.canManage;\n    };\n\n    /**\n     * Loads unique contact names for all the comments\n     *\n     * @return {Promise}\n     */\n    function loadContactNames () {\n      var contactsIndex = _.indexBy(vm.request.comments, 'contact_id');\n      var contactIDs = Object.keys(contactsIndex);\n\n      return Contact.all({\n        id: { IN: contactIDs }\n      }, { page: 1, size: 0 })\n        .then(function (contacts) {\n          vm.comment.contacts = _.indexBy(contacts.list, 'contact_id');\n        });\n    }\n\n    /**\n     * Loads the comments for current leave request\n     *\n     * @return {Promise}\n     */\n    function loadCommentsAndContactNames () {\n      return vm.request.loadComments()\n        .then(function () {\n          $rootScope.$broadcast('LeaveRequestPopup::requestObjectUpdated');\n          // loadComments sets the comments on request object instead of returning it\n          vm.request.comments.length && loadContactNames();\n        });\n    }\n\n    /**\n     * Loads the contact id of the currently logged in user.\n     *\n     * @return {Promise}\n     */\n    function loadLoggedInContactId () {\n      vm.loading.component = true;\n\n      return Session.get().then(function (value) {\n        loggedInContactId = value.contactId;\n      })\n      .then(function () {\n        vm.loading.component = false;\n      });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-request-popup-comments-tab.component.js"),
eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-request-popup-details-tab.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/models/session.model',\n  'leave-absences/shared/models/calendar.model'\n], function (_, moment, components) {\n  components.component('leaveRequestPopupDetailsTab', {\n    bindings: {\n      absencePeriods: '<',\n      absenceTypes: '<',\n      balance: '=',\n      checkSubmitConditions: '=',\n      request: '<',\n      isLeaveStatus: '<',\n      leaveType: '<',\n      isMode: '<',\n      isSelfRecord: '<',\n      period: '=',\n      isRole: '<',\n      selectedAbsenceType: '='\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-request-popup/leave-request-popup-details-tab.html';\n    }],\n    controllerAs: 'detailsTab',\n    controller: DetailsTabController\n  });\n\n  DetailsTabController.$inject = ['$controller', '$log', '$rootScope', '$q', 'HR_settings', 'shared-settings', 'Calendar', 'OptionGroup', 'PublicHoliday', 'LeaveRequest'];\n\n  function DetailsTabController ($controller, $log, $rootScope, $q, HRSettings, sharedSettings, Calendar, OptionGroup, PublicHoliday, LeaveRequest) {\n    $log.debug('Component: leave-request-popup-details-tab');\n    var originalOpeningBalance = null;\n    var listeners = [];\n    var vm = this;\n\n    vm.canManage = false;\n    vm.calendar = {};\n    vm.errors = [];\n    vm.requestDayTypes = [];\n    vm.statusNames = sharedSettings.statusNames;\n    vm.loading = {\n      tab: false,\n      showBalanceChange: false,\n      fromDayTypes: false,\n      toDayTypes: false\n    };\n    vm.pagination = {\n      currentPage: 1,\n      filteredbreakdown: vm.balance.change.breakdown,\n      numPerPage: 7,\n      totalItems: vm.balance.change.breakdown.length,\n      pageChanged: pageChanged\n    };\n    vm.uiOptions = {\n      isChangeExpanded: false,\n      multipleDays: true,\n      userDateFormat: HRSettings.DATE_FORMAT,\n      showBalance: false,\n      date: {\n        from: {\n          show: false,\n          options: {\n            startingDay: 1,\n            showWeeks: false\n          }\n        },\n        to: {\n          show: false,\n          options: {\n            minDate: null,\n            maxDate: null,\n            startingDay: 1,\n            showWeeks: false\n          }\n        },\n        expiry: {\n          show: false,\n          options: {\n            minDate: null,\n            maxDate: null,\n            startingDay: 1,\n            showWeeks: false\n          }\n        }\n      }\n    };\n\n    vm.calculateBalanceChange = calculateBalanceChange;\n    vm.changeInNoOfDays = changeInNoOfDays;\n    vm.isLeaveType = isLeaveType;\n    vm.loadAbsencePeriodDatesTypes = loadAbsencePeriodDatesTypes;\n    vm.updateAbsencePeriodDatesTypes = updateAbsencePeriodDatesTypes;\n    vm.updateBalance = updateBalance;\n    vm._canCalculateChange = _canCalculateChange;\n    vm._calculateOpeningAndClosingBalance = _calculateOpeningAndClosingBalance;\n    vm._checkAndSetAbsencePeriod = _checkAndSetAbsencePeriod;\n    vm._convertDateFormatFromServer = _convertDateFormatFromServer;\n    vm._convertDateToServerFormat = _convertDateToServerFormat;\n    vm._loadCalendar = _loadCalendar;\n    vm._reset = _reset;\n    vm._setDates = _setDates;\n    vm._setDateAndTypes = _setDateAndTypes;\n    vm._setMinMaxDate = _setMinMaxDate;\n    vm.$onDestroy = unsubscribeFromEvents;\n\n    (function init () {\n      $controller(_.capitalize(getLeaveType(vm.leaveType, vm.request)) + 'RequestCtrl', { parentCtrl: vm });\n\n      vm.canManage = vm.isRole('manager') || vm.isRole('admin');\n      vm.loading.tab = true;\n      initListeners();\n\n      vm.initChildController()\n      .then(function () {\n        return $q.all([\n          vm._loadCalendar(),\n          loadDayTypes()\n        ]);\n      })\n      .then(initDates)\n      .then(initOriginalOpeningBalance)\n      .then(function () {\n        return $q.all([\n          setDaySelectionMode(),\n          initBalanceChange()\n        ]);\n      })\n      .catch(handleError)\n      .finally(function () {\n        vm.loading.tab = false;\n      });\n    }());\n\n    /**\n     * Calculate change in balance, it updates local balance variables.\n     *\n     * @return {Promise} empty promise if all required params are not set\n     *   otherwise promise from server\n     */\n    function calculateBalanceChange () {\n      vm._setDateAndTypes();\n\n      if (!vm._canCalculateChange()) { return $q.resolve(); }\n\n      vm.loading.showBalanceChange = true;\n\n      return vm.request.calculateBalanceChange()\n        .then(setBalanceChange)\n        .catch(handleError);\n    }\n\n    /**\n     * Change handler when changing no. of days like Multiple Days or Single Day.\n     * It will reset dates, day types, change balance.\n     */\n    function changeInNoOfDays () {\n      vm._reset();\n      vm._calculateOpeningAndClosingBalance();\n    }\n\n    /**\n     * This method will be used on the view to return a list of available\n     * leave request day types (All day, Half-day AM, Half-day PM, Non working day,\n     * Weekend, Public holiday) for the given date (which is the date\n     * selected by the user via datepicker)\n     *\n     * If no date is passed, then no list is returned\n     *\n     * @param  {Date} date\n     * @param  {String} dayType - set to from if from date is selected else to\n     * @return {Promise} of array with day types\n     */\n    function filterLeaveRequestDayTypes (date, dayType) {\n      var listToReturn;\n\n      if (!date) {\n        return $q.reject([]);\n      }\n\n      // Make a copy of the list\n      listToReturn = vm.requestDayTypes.slice(0);\n      date = vm._convertDateToServerFormat(date);\n\n      return PublicHoliday.isPublicHoliday(date)\n        .then(function (result) {\n          if (result) {\n            return listToReturn.filter(function (publicHoliday) {\n              return publicHoliday.name === 'public_holiday';\n            });\n          }\n\n          return getDayTypesFromDate(date, listToReturn)\n            .then(function (inCalendarList) {\n              return inCalendarList.length\n                ? inCalendarList\n                : listToReturn.filter(function (dayType) {\n                  return _.includes(['all_day', 'half_day_am', 'half_day_pm'], dayType.name);\n                });\n            });\n        })\n        .then(function (listToReturn) {\n          setDayType(dayType, listToReturn);\n\n          return listToReturn;\n        });\n    }\n\n    /**\n     * Gets list of day types if its found to be weekend or non working in calendar\n     *\n     * @param {Date} date to Checks\n     * @param {Array} listOfDayTypes array of day types\n     * @return {Array} non-empty if found else empty array\n     */\n    function getDayTypesFromDate (date, listOfDayTypes) {\n      date = moment(date);\n\n      return $q.all([\n        vm.calendar.isNonWorkingDay(date),\n        vm.calendar.isWeekend(date)\n      ]).then(function (results) {\n        return results[0] ? 'non_working_day' : (results[1] ? 'weekend' : null);\n      })\n      .then(function (nameFilter) {\n        return !nameFilter ? [] : listOfDayTypes.filter(function (day) {\n          return day.name === nameFilter;\n        });\n      });\n    }\n\n    /**\n     * Gets leave type.\n     *\n     * @return {String} leave type\n     */\n    function getLeaveType () {\n      return vm.request ? vm.request.request_type : (vm.leaveType || null);\n    }\n\n    /**\n     * Gets currently selected absence type from leave request type_id\n     *\n     * @return {Object} absence type object\n     */\n    function getSelectedAbsenceType () {\n      return _.find(vm.absenceTypes, function (absenceType) {\n        return absenceType.id === vm.request.type_id;\n      });\n    }\n\n    /**\n     * Gets original balance change breakdown that cannot be affected by,\n     * for example, work pattern changes.\n     *\n     * @return {Promise}\n     */\n    function getOriginalBalanceChange () {\n      vm._setDateAndTypes();\n\n      vm.loading.showBalanceChange = true;\n\n      return vm.request.getBalanceChangeBreakdown()\n        .then(setBalanceChange)\n        .catch(handleError);\n    }\n\n    /**\n     * Handles errors\n     *\n     * @param {Array|Object}\n     */\n    function handleError (errors) {\n      $rootScope.$broadcast('LeaveRequestPopup::handleError', _.isArray(errors) ? errors : [errors]);\n      vm.loading.fromDayTypes = false;\n      vm.loading.showBalanceChange = false;\n      vm.loading.tab = false;\n      vm.loading.toDayTypes = false;\n    }\n\n    /**\n     * Initiates the balance change breakdown\n     *\n     * @return {Promise}\n     */\n    function initBalanceChange () {\n      return (vm.isMode('edit') ? getOriginalBalanceChange() : calculateBalanceChange());\n    }\n\n    /**\n     * Checks if popup is opened in given leave type like `leave` or `sickness` or 'toil'\n     *\n     * @param {String} leaveTypeParam to check the leave type of current request\n     * @return {Boolean}\n     */\n    function isLeaveType (leaveTypeParam) {\n      return vm.request.request_type === leaveTypeParam;\n    }\n\n    /**\n     * Initialize from and to dates and day types.\n     * It will also set the day types.\n     *\n     * @return {Promise}\n     */\n    function initDates () {\n      if (!vm.isMode('create')) {\n        var attributes = vm.request.attributes();\n\n        vm.uiOptions.fromDate = vm._convertDateFormatFromServer(vm.request.from_date);\n\n        return vm.loadAbsencePeriodDatesTypes(vm.uiOptions.fromDate, 'from')\n          .then(function () {\n            // to_date and type has been reset in above call so reinitialize from clone\n            vm.request.to_date = attributes.to_date;\n            vm.request.to_date_type = attributes.to_date_type;\n            vm.uiOptions.toDate = vm._convertDateFormatFromServer(vm.request.to_date);\n            return vm.loadAbsencePeriodDatesTypes(vm.uiOptions.toDate, 'to');\n          });\n      } else {\n        return $q.resolve();\n      }\n    }\n\n    /**\n     * Initialises listeners\n     */\n    function initListeners () {\n      listeners.push(\n        $rootScope.$on('LeaveRequestPopup::updateBalance', vm.updateBalance)\n      );\n    }\n\n    /**\n     * Initialize the original opening balance when in edit mode and the\n     * request is approved. This allows to display the opening balance before\n     * the request was created.\n     *\n     * The formula is absence type remainder + balance change. Since\n     * Balance Change is a negative number so it needs to be subtracted.\n     */\n    function initOriginalOpeningBalance () {\n      if (vm.isMode('edit') && (\n        vm.isLeaveStatus(sharedSettings.statusNames.approved) ||\n        vm.isLeaveStatus(sharedSettings.statusNames.adminApproved)\n      )) {\n        originalOpeningBalance = {\n          absenceTypeId: vm.request.type_id,\n          value: vm.selectedAbsenceType.remainder - vm.request.balance_change\n        };\n      }\n    }\n\n    /**\n     * Loads absence types and calendar data on component initialization and\n     * when they need to be updated.\n     *\n     * @param {Date} date - the selected date\n     * @param {String} dayType - set to from if from date is selected else to\n     * @return {Promise}\n     */\n    function loadAbsencePeriodDatesTypes (date, dayType) {\n      var oldPeriodId = vm.period.id;\n      dayType = dayType || 'from';\n      vm.loading[dayType + 'DayTypes'] = true;\n\n      return vm._checkAndSetAbsencePeriod(date)\n        .then(function () {\n          var isInCurrentPeriod = oldPeriodId === vm.period.id;\n\n          if (!isInCurrentPeriod) {\n            // partial reset is required when user has selected a to date and\n            // then changes absence period from from date\n            // no reset required for single days and to date changes\n            if (vm.uiOptions.multipleDays && dayType === 'from') {\n              vm.uiOptions.showBalance = false;\n              vm.uiOptions.toDate = null;\n              vm.request.to_date = null;\n              vm.request.to_date_type = null;\n            }\n\n            return $q.all([\n              vm._loadCalendar()\n            ]);\n          }\n        })\n        .then(function () {\n          vm._setMinMaxDate();\n\n          return filterLeaveRequestDayTypes(date, dayType);\n        })\n        .finally(function () {\n          /**\n           * after the request is completed fromDayTypes or toDayTypes are\n           * set to false and the corresponding field is shown on the ui.\n           */\n          vm.loading[dayType + 'DayTypes'] = false;\n        });\n    }\n\n    /**\n     * Initializes leave request day types\n     *\n     * @return {Promise}\n     */\n    function loadDayTypes () {\n      return OptionGroup.valuesOf('hrleaveandabsences_leave_request_day_type')\n        .then(function (dayTypes) {\n          vm.requestDayTypes = dayTypes;\n        });\n    }\n\n    /**\n     * It filters the breakdown to obtain the ones for currently selected page.\n     */\n    function pageChanged () {\n      var begin = (vm.pagination.currentPage - 1) * vm.pagination.numPerPage;\n      var end = begin + vm.pagination.numPerPage;\n\n      vm.pagination.filteredbreakdown = vm.balance.change.breakdown.slice(begin, end);\n    }\n\n    /**\n     * Helper function to reset pagination for balance breakdow\n     */\n    function rePaginate () {\n      vm.pagination.totalItems = vm.balance.change.breakdown.length;\n      vm.pagination.filteredbreakdown = vm.balance.change.breakdown;\n      vm.pagination.pageChanged();\n    }\n\n    /**\n     * Sets balance change breakdown after it was retrieved or calculated\n     *\n     * @param {Object} balanceChange\n     */\n    function setBalanceChange (balanceChange) {\n      if (balanceChange) {\n        vm.balance.change = balanceChange;\n\n        vm._calculateOpeningAndClosingBalance();\n        rePaginate();\n      }\n\n      vm.loading.showBalanceChange = false;\n    }\n\n    /**\n     * Sets day selection mode: multiple days or a single day\n     */\n    function setDaySelectionMode () {\n      if ((vm.isMode('edit') && vm.request.from_date === vm.request.to_date) ||\n        (vm.isMode('create') && vm.isLeaveType('sickness'))) {\n        vm.uiOptions.multipleDays = false;\n      }\n    }\n\n    /**\n     * Sets the collection for given day types to sent list of day types,\n     * also initializes the day types\n     *\n     * @param {String} dayType like `from` or `to`\n     * @param {Array} listOfDayTypes collection of available day types\n     */\n    function setDayType (dayType, listOfDayTypes) {\n      // will create either of leaveRequestFromDayTypes or leaveRequestToDayTypes key\n      var keyForDayTypeCollection = 'request' + _.startCase(dayType) + 'DayTypes';\n\n      vm[keyForDayTypeCollection] = listOfDayTypes;\n\n      if (vm.isMode('create')) {\n        vm.request[dayType + '_date_type'] = vm[keyForDayTypeCollection][0].value;\n      }\n    }\n\n    /**\n     * Destroys all event listeners\n     */\n    function unsubscribeFromEvents () {\n      _.forEach(listeners, function (listener) {\n        listener();\n      });\n    }\n\n    /**\n     * This should be called whenever a date has been changed\n     * First it syncs `from` and `to` date, if it's in 'single day' mode\n     * Then, if all the dates are there, it gets the balance change\n     *\n     * @param {Date} date - the selected date\n     * @param {String} dayType - set to from if from date is selected else to\n     * @return {Promise}\n     */\n    function updateAbsencePeriodDatesTypes (date, dayType) {\n      var oldPeriodId = vm.period.id;\n\n      return vm.loadAbsencePeriodDatesTypes(date, dayType)\n        .then(function () {\n          var isInCurrentPeriod = oldPeriodId === vm.period.id;\n\n          if (isInCurrentPeriod) {\n            return vm.updateBalance();\n          } else {\n            $rootScope.$broadcast('LeaveRequestPopup::loadAbsenceTypes');\n          }\n        })\n        .catch(function (errors) {\n          handleError(errors);\n          vm._setDateAndTypes();\n        });\n    }\n\n    /**\n     * Whenever the absence type changes, update the balance opening.\n     * Also the balance change needs to be recalculated, if the `from` and `to`\n     * dates have been already selected\n     */\n    function updateBalance () {\n      vm.selectedAbsenceType = getSelectedAbsenceType();\n      // calculate balance only if current absence type exists\n      if (vm.selectedAbsenceType) {\n        // get the `balance` of the newly selected absence type\n        vm.balance.opening = vm.selectedAbsenceType.remainder;\n\n        vm.calculateBalanceChange();\n      } else {\n        // hide the show balance block\n        vm.uiOptions.showBalance = false;\n      }\n    }\n\n    /**\n     * If change can be calculated\n     */\n    function _canCalculateChange () {\n      return !!vm.request.from_date && !!vm.request.to_date &&\n        !!vm.request.from_date_type && !!vm.request.to_date_type;\n    }\n\n    /**\n     * Calculates and updates opening and closing balances.\n     *\n     * For the opening balance, when in edit mode, if the selected absence type\n     * is the same as the request absence type, the opening balance is the\n     * original opening balance value, otherwise it's the leave balance\n     * remainder.\n     *\n     * The closing balance is the opening balance + change amount.\n     */\n    function _calculateOpeningAndClosingBalance () {\n      if (originalOpeningBalance &&\n      originalOpeningBalance.absenceTypeId === vm.selectedAbsenceType.id) {\n        vm.balance.opening = originalOpeningBalance.value;\n      } else {\n        vm.balance.opening = vm.selectedAbsenceType.remainder;\n      }\n      // the change is negative so adding it will actually subtract it\n      vm.balance.closing = vm.balance.opening + vm.balance.change.amount;\n    }\n\n    /**\n     * Finds if date is in any absence period and sets absence period for the given date\n     *\n     * @param {Date/String} date\n     * @return {Promise} with true value if period found else rejected false\n     */\n    function _checkAndSetAbsencePeriod (date) {\n      var formattedDate = moment(date).format(vm.uiOptions.userDateFormat.toUpperCase());\n\n      vm.period = _.find(vm.absencePeriods, function (period) {\n        return period.isInPeriod(formattedDate);\n      });\n\n      if (!vm.period) {\n        vm.period = {};\n        // inform user if absence period is not found\n        vm.loading['fromDayTypes'] = false;\n        return $q.reject('Please change date as it is not in any absence period');\n      }\n\n      return $q.resolve(true);\n    }\n\n    /**\n     * Converts given date to javascript date as expected by uib-datepicker\n     *\n     * @param {String} date from server\n     * @return {Date}\n     */\n    function _convertDateFormatFromServer (date) {\n      return moment(date, sharedSettings.serverDateFormat).toDate();\n    }\n\n    /**\n     * Converts given date to server format\n     *\n     * @param {Date} date\n     * @return {String} date converted to server format\n     */\n    function _convertDateToServerFormat (date) {\n      return moment(date).format(sharedSettings.serverDateFormat);\n    }\n\n    /**\n     * Initializes user's calendar (work patterns)\n     *\n     * @return {Promise}\n     */\n    function _loadCalendar () {\n      return Calendar.get(vm.request.contact_id, vm.period.start_date, vm.period.end_date)\n        .then(function (usersCalendar) {\n          vm.calendar = usersCalendar;\n        });\n    }\n\n    /**\n     * Sets dates and types for vm.request from UI\n     */\n    function _setDates () {\n      vm.request.from_date = vm.uiOptions.fromDate ? vm._convertDateToServerFormat(vm.uiOptions.fromDate) : null;\n      vm.request.to_date = vm.uiOptions.toDate ? vm._convertDateToServerFormat(vm.uiOptions.toDate) : null;\n\n      if (!vm.uiOptions.multipleDays && vm.uiOptions.fromDate) {\n        vm.uiOptions.toDate = vm.uiOptions.fromDate;\n        vm.request.to_date = vm.request.from_date;\n      }\n    }\n\n    /**\n     * Sets dates and types for vm.request from UI\n     */\n    function _setDateAndTypes () {\n      vm._setDates();\n\n      if (vm.uiOptions.multipleDays) {\n        vm.uiOptions.showBalance = !!vm.request.from_date && !!vm.request.from_date_type && !!vm.request.to_date && !!vm.request.to_date_type && !!vm.period.id;\n      } else {\n        if (vm.uiOptions.fromDate) {\n          vm.request.to_date_type = vm.request.from_date_type;\n        }\n\n        vm.uiOptions.showBalance = !!vm.request.from_date && !!vm.request.from_date_type && !!vm.period.id;\n      }\n    }\n\n    /**\n     * Sets the min and max for to date from absence period. It also sets the\n     * init/starting date which user can select from. For multiple days request\n     * user can select to date which is one more than the the start date.\n     */\n    function _setMinMaxDate () {\n      if (vm.uiOptions.fromDate) {\n        var nextFromDay = moment(vm.uiOptions.fromDate).add(1, 'd').toDate();\n\n        vm.uiOptions.date.to.options.minDate = nextFromDay;\n        vm.uiOptions.date.to.options.initDate = nextFromDay;\n\n        // also re-set to date if from date is changing and less than to date\n        if (vm.uiOptions.toDate && moment(vm.uiOptions.toDate).isBefore(vm.uiOptions.fromDate)) {\n          vm.uiOptions.toDate = vm.uiOptions.fromDate;\n        }\n      } else {\n        vm.uiOptions.date.to.options.minDate = vm._convertDateFormatFromServer(vm.period.start_date);\n        vm.uiOptions.date.to.options.initDate = vm.uiOptions.date.to.options.minDate;\n      }\n\n      vm.uiOptions.date.to.options.maxDate = vm._convertDateFormatFromServer(vm.period.end_date);\n    }\n\n    /**\n     * Resets data in dates, types, balance.\n     */\n    function _reset () {\n      vm.uiOptions.toDate = vm.uiOptions.fromDate;\n      vm.request.to_date_type = vm.request.from_date_type;\n      vm.request.to_date = vm.request.from_date;\n\n      vm.calculateBalanceChange();\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-request-popup-details-tab.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-request-popup-files-tab',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/services/file-upload',\n  'common/services/file-mime-types',\n  'common/services/hr-settings'\n], function (_, moment, components) {\n  components.component('leaveRequestPopupFilesTab', {\n    bindings: {\n      canManage: '<',\n      fileUploader: '=',\n      mode: '<',\n      request: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-request-popup/leave-request-popup-files-tab.html';\n    }],\n    controllerAs: 'filesTab',\n    controller: ['$log', '$rootScope', '$q', 'HR_settings', 'shared-settings', 'OptionGroup', 'FileUpload', 'fileMimeTypes', controller]\n  });\n\n  function controller ($log, $rootScope, $q, HRSettings, sharedSettings, OptionGroup, FileUpload, fileMimeTypes) {\n    $log.debug('Component: leave-request-popup-files-tab');\n\n    var fileExtensions = [];\n    var listeners = [];\n    var mimeTypes = {};\n    var vm = Object.create(this);\n    vm.filesLoaded = false;\n    vm.today = Date.now();\n    vm.userDateFormatWithTime = HRSettings.DATE_FORMAT + ' HH:mm';\n    vm.userDateFormat = HRSettings.DATE_FORMAT;\n\n    vm.listFileTypes = listFileTypes;\n    vm.$onDestroy = unsubscribeFromEvents;\n\n    /**\n     * Checks if user can upload more file, it totals the number of already\n     * uploaded files and those which are in queue and compares it to limit.\n     *\n     * @return {Boolean} true is user can upload more else false\n     */\n    vm.canUploadMore = function () {\n      return vm.getFilesCount() < sharedSettings.fileUploader.queueLimit;\n    };\n\n    /**\n     * Format a date-time into user format and returns\n     *\n     * @return {String}\n     */\n    vm.formatDateTime = function (dateTime) {\n      return moment(dateTime, sharedSettings.serverDateTimeFormat).format(vm.userDateFormat.toUpperCase() + ' HH:mm');\n    };\n\n    /**\n     * Returns the attachment author name\n     * @param {String} contactId\n     *\n     * @return {String}\n     */\n    vm.getAuthorName = function (contactId) {\n      // @TODO Author name cannot be fetched for already uploaded attachments\n      // as the attachment API does not support saving the contact id\n      if (contactId === vm.request.contact_id) {\n        return 'Me -';\n      }\n    };\n\n    /**\n     * Calculates the total number of files associated with request.\n     *\n     * @return {Number} of files\n     */\n    vm.getFilesCount = function () {\n      var filesToDelete = filesMarkedForDeletion();\n      var queue = fileUploaderQueue();\n\n      return vm.request.files.length + queue.length - filesToDelete.length;\n    };\n\n    /**\n     * Decides visibility of remove attachment button\n     * @param {Object} attachment - attachment object\n     *\n     * @return {Boolean}\n     */\n    vm.removeAttachmentVisibility = function (attachment) {\n      return !attachment.attachment_id || vm.canManage;\n    };\n\n    (function init () {\n      $rootScope.$broadcast('LeaveRequestPopup::childComponent::register');\n      initListeners();\n\n      $q.all([\n        loadSupportedFileExtensions(),\n        loadAttachments()\n      ])\n      .then(initFileUploader)\n      .finally(function () {\n        vm.filesLoaded = true;\n      });\n    }());\n\n    /**\n     * Returns an array of files marked for deletion\n     *\n     * @return {Array}\n     */\n    function filesMarkedForDeletion () {\n      return _.filter(vm.request.files, function (file) {\n        return file.toBeDeleted;\n      });\n    }\n\n    /**\n     * Returns the file uploader queue\n     *\n     * @return {Array}\n     */\n    function fileUploaderQueue () {\n      return (vm.fileUploader && vm.fileUploader.queue)\n        ? vm.fileUploader.queue\n        : [];\n    }\n\n    /**\n     * Initializes all the listeners\n     */\n    function initListeners () {\n      listeners.push(\n        $rootScope.$on('LeaveRequestPopup::submit', uploadAttachments)\n      );\n    }\n\n    /**\n     * Initializes the file uploader object\n     */\n    function initFileUploader () {\n      loadMimeTypesOfSupportedFileExtensions()\n        .then(function () {\n          vm.fileUploader = FileUpload.uploader({\n            entityTable: 'civicrm_hrleaveandabsences_leave_request',\n            crmAttachmentToken: sharedSettings.attachmentToken,\n            queueLimit: sharedSettings.fileUploader.queueLimit,\n            allowedMimeTypes: mimeTypes\n          });\n        });\n    }\n\n    /**\n     * Returns a string of allowed files extensions for upload\n     * @returns {string}\n     */\n    function listFileTypes () {\n      return fileExtensions.length > 0\n        ? fileExtensions.map(function (ext) {\n          return ext.label;\n        }).join(', ')\n        : '';\n    }\n\n    /**\n     * Loads the attachments, and broadcasts an event when they are loaded\n     */\n    function loadAttachments () {\n      return vm.request.loadAttachments()\n        .then(function () {\n          $rootScope.$broadcast('LeaveRequestPopup::requestObjectUpdated');\n        });\n    }\n\n    /**\n     * Loads the mime types for supported file extensions\n     *\n     * @returns {Promise}\n     */\n    function loadMimeTypesOfSupportedFileExtensions () {\n      return $q.all(fileExtensions.map(function (fileExtension) {\n        return fileMimeTypes.getMimeTypeFor(fileExtension.label)\n          .then(function (mimeType) {\n            mimeTypes[fileExtension.label] = mimeType;\n          });\n      }))\n      .catch(function () {\n        // if the API calls throws an error or fails, \"allowedMimeTypes\" will be undefined\n        // hence the default file extension will be set to the uploader in file-upload.js\n        mimeTypes = null;\n      });\n    }\n\n    /**\n     * Load file extensions which are supported for upload and creates uploader object\n     *\n     * @return {Promise}\n     */\n    function loadSupportedFileExtensions () {\n      return OptionGroup.valuesOf('safe_file_extension')\n        .then(function (fileExtensionsData) {\n          fileExtensions = fileExtensionsData;\n        });\n    }\n\n    /**\n     * Gets called when the component is destroyed\n     */\n    function unsubscribeFromEvents () {\n      // destroy all the event\n      _.forEach(listeners, function (listener) {\n        listener();\n      });\n    }\n\n    /**\n     * * Upload attachment in file uploder's queue\n     * @param {Object} e - event object\n     * @param {Function} callBack - call back function\n     */\n    function uploadAttachments (e, callBack) {\n      if (vm.fileUploader.queue && vm.fileUploader.queue.length > 0) {\n        vm.fileUploader.uploadAll({ entityID: vm.request.id })\n          .then(function () { callBack(); })\n          .catch(callBack);\n      } else {\n        callBack();\n      }\n    }\n\n    return vm;\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-request-popup-files-tab.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/components/leave-request-record-actions.component',[\n  'leave-absences/shared/modules/components',\n  'common/services/hr-settings'\n], function (components) {\n  components.component('leaveRequestRecordActions', {\n    bindings: {\n      btnClass: '@',\n      contactId: '<',\n      selectedContactId: '<',\n      isSelfRecord: '<'\n    },\n    templateUrl: ['shared-settings', function (sharedSettings) {\n      return sharedSettings.sharedPathTpl + 'components/leave-request-record-actions.html';\n    }],\n    controllerAs: 'vm',\n    controller: ['$log', 'LeavePopup', controller]\n  });\n\n  function controller ($log, LeavePopup) {\n    $log.debug('Component: leave-request-record-actions');\n\n    var vm = this;\n\n    vm.leaveRequestOptions = [\n      { type: 'leave', icon: 'briefcase', label: 'Leave' },\n      { type: 'sickness', icon: 'stethoscope', label: 'Sickness' },\n      { type: 'toil', icon: 'calendar-plus-o', label: 'Overtime' }\n    ];\n\n    vm.openLeavePopup = openLeavePopup;\n\n    /**\n     * Opens the leave request popup\n     *\n     * @param {Object} leaveRequest\n     * @param {String} leaveType\n     * @param {String} selectedContactId\n     * @param {Boolean} isSelfRecord\n     */\n    function openLeavePopup (leaveRequest, leaveType, selectedContactId, isSelfRecord) {\n      LeavePopup.openModal.apply(LeavePopup, arguments);\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/leave-request-record-actions.component.js"),eval("/* eslint-env amd */\ndefine('leave-absences/shared/components/staff-leave-report.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/shared/modules/components',\n  'common/services/pub-sub'\n], function (_, moment, components) {\n  components.component('staffLeaveReport', {\n    bindings: {\n      contactId: '<'\n    },\n    templateUrl: ['shared-settings', function (settings) {\n      return settings.sharedPathTpl + 'components/staff-leave-report.html';\n    }],\n    controllerAs: 'report',\n    controller: [\n      '$log', '$q', '$rootScope', 'checkPermissions', 'AbsencePeriod', 'AbsenceType',\n      'Entitlement', 'LeaveRequest', 'OptionGroup', 'pubSub', 'HR_settings',\n      'shared-settings', controller\n    ]\n  });\n\n  function controller ($log, $q, $rootScope, checkPermissions, AbsencePeriod,\n  AbsenceType, Entitlement, LeaveRequest, OptionGroup, pubSub,\n  HRSettings, sharedSettings) {\n    $log.debug('Component: staff-leave-report');\n\n    var requestSort = 'from_date ASC';\n    var vm = this;\n\n    vm.absencePeriods = [];\n    vm.absenceTypes = {};\n    vm.absenceTypesFiltered = {};\n    vm.dateFormat = HRSettings.DATE_FORMAT;\n    vm.leaveRequestStatuses = {};\n    vm.selectedPeriod = null;\n    vm.role = ($rootScope.section === 'absence-tab' ? 'admin' : 'staff');\n    vm.loading = {\n      content: true,\n      page: true\n    };\n    vm.sections = {\n      approved: { open: false, data: [], loading: false, loadFn: loadApprovedRequests },\n      entitlements: { open: false, data: [], loading: false, loadFn: loadEntitlementsBreakdown },\n      expired: { open: false, data: [], loading: false, loadFn: loadExpiredBalanceChanges },\n      holidays: { open: false, data: [], loading: false, loadFn: loadPublicHolidaysRequests },\n      pending: { open: false, data: [], loading: false, loadFn: loadPendingRequests },\n      other: { open: false, data: [], loading: false, loadFn: loadOtherRequests }\n    };\n\n    /**\n     * Labels the given period according to whether it's current or not\n     *\n     * @param  {AbsencePeriodInstance} period\n     * @return {string}\n     */\n    vm.labelPeriod = function (period) {\n      return period.current ? 'Current Period (' + period.title + ')' : period.title;\n    };\n\n    /**\n     * Refreshes all data that is dependend on the selected absence period,\n     * and clears the cached data of closed sections\n     */\n    vm.refresh = function () {\n      vm.loading.content = true;\n\n      $q.all([\n        loadEntitlements(),\n        loadBalanceChanges()\n      ])\n      .then(function () {\n        vm.loading.content = false;\n      })\n      .then(function () {\n        return $q.all([\n          loadOpenSectionsData(),\n          clearSectionsData()\n        ]);\n      });\n    };\n\n    /**\n     * Opens/closes the given section. When opening it triggers the\n     * load function if no cached data is present\n     *\n     * @param {string} sectionName\n     */\n    vm.toggleSection = function (sectionName) {\n      var section = vm.sections[sectionName];\n      section.open = !section.open;\n\n      if (section.open && !section.data.length) {\n        callSectionLoadFn(section);\n      }\n    };\n\n    init();\n\n    function init () {\n      $q.all([\n        loadStatuses(),\n        loadAbsenceTypes(),\n        loadAbsencePeriods()\n      ])\n      .then(function () {\n        vm.loading.page = false;\n      })\n      .then(function () {\n        return $q.all([\n          loadEntitlements(),\n          loadBalanceChanges()\n        ]);\n      })\n      .then(function () {\n        vm.loading.content = false;\n      });\n\n      registerEvents();\n    }\n\n    /**\n     * Calls the load function of the given data, and puts the section\n     * in and out of loading mode\n     *\n     * @param  {Object} section\n     * @return {Promise}\n     */\n    function callSectionLoadFn (section) {\n      section.loading = true;\n\n      return section.loadFn().then(function () {\n        section.loading = false;\n      });\n    }\n\n    /**\n     * Clears the cached data of all sections\n     */\n    function clearSectionsData () {\n      Object.values(vm.sections)\n        .forEach(function (section) {\n          section.data = [];\n        });\n    }\n\n    /**\n     * NOTE: This should be just temporary, see PCHR-1810\n     * Loads all the possible statuses of a leave request\n     *\n     * @return {Promise}\n     */\n    function loadStatuses () {\n      return OptionGroup.valuesOf('hrleaveandabsences_leave_request_status')\n        .then(function (statuses) {\n          vm.leaveRequestStatuses = _.indexBy(statuses, 'value');\n        });\n    }\n\n    /**\n     * Loads the absence periods\n     *\n     * @return {Promise}\n     */\n    function loadAbsencePeriods () {\n      return AbsencePeriod.all()\n        .then(function (absencePeriods) {\n          vm.absencePeriods = _.sortBy(absencePeriods, 'start_date');\n          vm.selectedPeriod = _.find(vm.absencePeriods, function (period) {\n            return period.current === true;\n          });\n        });\n    }\n\n    /**\n     * Loads the absence types\n     *\n     * @return {Promise}\n     */\n    function loadAbsenceTypes () {\n      return AbsenceType.all()\n        .then(function (absenceTypes) {\n          vm.absenceTypes = _.indexBy(absenceTypes, 'id');\n        });\n    }\n\n    /**\n     * Loads the approved requests\n     *\n     * @return {Promise}\n     */\n    function loadApprovedRequests () {\n      return LeaveRequest.all({\n        contact_id: vm.contactId,\n        from_date: { from: vm.selectedPeriod.start_date },\n        to_date: { to: vm.selectedPeriod.end_date },\n        status_id: valueOfRequestStatus(sharedSettings.statusNames.approved)\n      }, null, requestSort, null, false)\n      .then(function (leaveRequests) {\n        vm.sections.approved.data = leaveRequests.list;\n      });\n    }\n\n    /**\n     * Loads the balance changes of the various sections\n     * and groups them by absence type\n     *\n     * @return {Promise}\n     */\n    function loadBalanceChanges () {\n      return $q.all([\n        LeaveRequest.balanceChangeByAbsenceType(vm.contactId, vm.selectedPeriod.id, null, true),\n        LeaveRequest.balanceChangeByAbsenceType(vm.contactId, vm.selectedPeriod.id, [\n          valueOfRequestStatus(sharedSettings.statusNames.approved)\n        ]),\n        LeaveRequest.balanceChangeByAbsenceType(vm.contactId, vm.selectedPeriod.id, [\n          valueOfRequestStatus(sharedSettings.statusNames.awaitingApproval),\n          valueOfRequestStatus(sharedSettings.statusNames.moreInformationRequired)\n        ])\n      ])\n      .then(function (results) {\n        _.forEach(vm.absenceTypes, function (absenceType) {\n          absenceType.balanceChanges = {\n            publicHolidays: results[0][absenceType.id],\n            approved: results[1][absenceType.id],\n            pending: results[2][absenceType.id]\n          };\n        });\n      });\n    }\n\n    /**\n     * Loads the entitlements, including current and future balance,\n     * and groups the entitlements value and remainder by absence type\n     * Also Filters the absence types which allows overuse or allows\n     * accrual request or has entitlement more than 0\n     *\n     * @return {Promise}\n     */\n    function loadEntitlements () {\n      return Entitlement.all({\n        contact_id: vm.contactId,\n        period_id: vm.selectedPeriod.id\n      }, true)\n      .then(function (entitlements) {\n        vm.entitlements = entitlements;\n      })\n      .then(function () {\n        vm.absenceTypesFiltered = _.filter(vm.absenceTypes, function (absenceType) {\n          var entitlement = _.find(vm.entitlements, function (entitlement) {\n            return entitlement.type_id === absenceType.id;\n          });\n\n          // set entitlement to 0 if no entitlement is present\n          absenceType.entitlement = entitlement ? entitlement.value : 0;\n          absenceType.remainder = entitlement ? entitlement.remainder : { current: 0, future: 0 };\n\n          return !((absenceType.entitlement === 0) &&\n          (absenceType.allow_overuse !== '1') &&\n          (absenceType.allow_accruals_request !== '1'));\n        });\n      });\n    }\n\n    /**\n     * Loads the entitlements breakdown\n     *\n     * @return {Promise}\n     */\n    function loadEntitlementsBreakdown () {\n      return Entitlement.breakdown({\n        contact_id: vm.contactId,\n        period_id: vm.selectedPeriod.id\n      }, vm.entitlements)\n      .then(function () {\n        return processBreakdownsList(vm.entitlements);\n      })\n      .then(function (breakdownListFlatten) {\n        vm.sections.entitlements.data = breakdownListFlatten;\n      });\n    }\n\n    /**\n     * Loads the expired balance changes (Brought Forward, TOIL)\n     *\n     * @return {Promise}\n     */\n    function loadExpiredBalanceChanges () {\n      return $q.all([\n        Entitlement.breakdown({\n          contact_id: vm.contactId,\n          period_id: vm.selectedPeriod.id,\n          expired: true\n        }),\n        LeaveRequest.all({\n          contact_id: vm.contactId,\n          from_date: {from: vm.selectedPeriod.start_date},\n          to_date: {to: vm.selectedPeriod.end_date},\n          request_type: 'toil',\n          expired: true\n        }, null, requestSort, null, false)\n      ])\n        .then(function (results) {\n          return $q.all({\n            expiredBalanceChangesFlatten: processBreakdownsList(results[0]),\n            expiredTOILS: processExpiredTOILS(results[1].list)\n          });\n        })\n        .then(function (results) {\n          vm.sections.expired.data = results.expiredBalanceChangesFlatten.concat(results.expiredTOILS);\n          vm.sections.expired.data = _.sortBy(vm.sections.expired.data, 'expiry_date');\n        });\n    }\n\n    /**\n     * Loads the data of all the currently opened sections\n     *\n     * @return {Promise}\n     */\n    function loadOpenSectionsData () {\n      return $q.all(Object.values(vm.sections)\n        .filter(function (section) {\n          return section.open;\n        })\n        .map(function (section) {\n          return callSectionLoadFn(section);\n        }));\n    }\n\n    /**\n     * Loads the rejected/cancelled leave requests\n     *\n     * @return {Promise}\n     */\n    function loadOtherRequests () {\n      return LeaveRequest.all({\n        contact_id: vm.contactId,\n        from_date: { from: vm.selectedPeriod.start_date },\n        to_date: { to: vm.selectedPeriod.end_date },\n        status_id: { in: [\n          valueOfRequestStatus(sharedSettings.statusNames.rejected),\n          valueOfRequestStatus(sharedSettings.statusNames.cancelled)\n        ] }\n      }, null, requestSort, null, false)\n      .then(function (leaveRequests) {\n        vm.sections.other.data = leaveRequests.list;\n      });\n    }\n\n    /**\n     * Loads the currently pending leave requests\n     *\n     * @return {Promise}\n     */\n    function loadPendingRequests () {\n      return LeaveRequest.all({\n        contact_id: vm.contactId,\n        from_date: { from: vm.selectedPeriod.start_date },\n        to_date: { to: vm.selectedPeriod.end_date },\n        status_id: { in: [\n          valueOfRequestStatus(sharedSettings.statusNames.awaitingApproval),\n          valueOfRequestStatus(sharedSettings.statusNames.moreInformationRequired)\n        ] }\n      }, null, requestSort, null, false)\n      .then(function (leaveRequests) {\n        vm.sections.pending.data = leaveRequests.list;\n      });\n    }\n\n    /**\n     * Loads the leave requests associated to public holidays\n     *\n     * @return {Promise}\n     */\n    function loadPublicHolidaysRequests () {\n      return LeaveRequest.all({\n        contact_id: vm.contactId,\n        from_date: { from: vm.selectedPeriod.start_date },\n        to_date: { to: vm.selectedPeriod.end_date },\n        public_holiday: true\n      }, null, requestSort, null, false)\n      .then(function (leaveRequests) {\n        vm.sections.holidays.data = leaveRequests.list;\n      });\n    }\n\n    /**\n     * For each breakdowns, it sets the absence type id to\n     * each list entry (based on the entitlement they belong to)\n     * and flattens the result in the end to get one single list\n     *\n     * @param  {Array} list\n     *   each breakdown should contain `id` and `breakdown` properties\n     * @return {Promise} resolves to the flatten list\n     */\n    function processBreakdownsList (list) {\n      return $q.resolve()\n        .then(function () {\n          return list.map(function (listEntry) {\n            var entitlement = _.find(vm.entitlements, function (entitlement) {\n              return entitlement.id === listEntry.id;\n            });\n\n            return listEntry.breakdown.map(function (breakdownEntry) {\n              return _.assign(_.clone(breakdownEntry), {\n                type_id: entitlement.type_id\n              });\n            });\n          });\n        })\n        .then(function (breakdownList) {\n          return Array.prototype.concat.apply([], breakdownList);\n        });\n    }\n\n    /**\n     * Process each expired TOIL requests\n     *\n     * @param  {Array} list of expired TOIL request\n     * @return {Promise} resolves to the flatten list\n     */\n    function processExpiredTOILS (list) {\n      return $q.resolve()\n        .then(function () {\n          return list.map(function (listEntry) {\n            return {\n              'expiry_date': listEntry.toil_expiry_date,\n              'type': {\n                'label': 'Accrued TOIL'\n              }\n            };\n          });\n        });\n    }\n\n    /**\n     * Register events which will be called by other modules\n     */\n    function registerEvents () {\n      pubSub.subscribe('LeaveRequest::new', function () { vm.refresh(); });\n      pubSub.subscribe('LeaveRequest::edit', function () { vm.refresh(); });\n      pubSub.subscribe('LeaveRequest::deleted', function (leaveRequest) {\n        removeLeaveRequestFromItsSection(leaveRequest);\n      });\n    }\n\n    /**\n     * Removes the given leave request from the section it currently belongs to\n     * (only the \"approved\", \"pending\", and \"other\" sections support request removal)\n     *\n     * If the leave request belonged to either the \"approved\" or \"pending\" section,\n     * then the numbers of the section will be recalculated\n     *\n     * @param  {LeaveRequestInstance} leaveRequest\n     * @param  {Boolean} moveToOther If true, it moves the leave request to\n     *         the \"other\" section (if the section has already cached data)\n     * @return {Promise}\n     */\n    function removeLeaveRequestFromItsSection (leaveRequest, moveToOther) {\n      var sectionBelonged;\n\n      ['approved', 'pending', 'other'].forEach(function (sectionName) {\n        var sections = _.remove(vm.sections[sectionName].data, function (dataEntry) {\n          return dataEntry.id === leaveRequest.id;\n        });\n\n        sections.length && (sectionBelonged = sectionName);\n      });\n\n      if (sectionBelonged !== 'other') {\n        updateSectionNumbersWithLeaveRequestBalanceChange(leaveRequest, sectionBelonged);\n\n        if (moveToOther && vm.sections.other.data.length) {\n          vm.sections.other.data.push(leaveRequest);\n        }\n      }\n    }\n\n    /**\n     * Recalculates the section's balance change and remainder numbers with the\n     * given leave request's balance change\n     *\n     * @param {LeaveRequestInstance} leaveRequest\n     * @param {string} section\n     */\n    function updateSectionNumbersWithLeaveRequestBalanceChange (leaveRequest, section) {\n      var absenceType = vm.absenceTypes[leaveRequest.type_id];\n      var remainderType = (section === 'pending') ? 'future' : 'current';\n\n      absenceType.balanceChanges[section] -= leaveRequest.balance_change;\n      absenceType.remainder[remainderType] -= leaveRequest.balance_change;\n    }\n\n    /**\n     * Returns the value of the given leave request status\n     *\n     * @param  {string} statusName\n     * @return {integer}\n     */\n    function valueOfRequestStatus (statusName) {\n      return _.find(vm.leaveRequestStatuses, function (status) {\n        return status.name === statusName;\n      })['value'];\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/components/staff-leave-report.component.js"),
eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/leave-request.controller',[\n  'leave-absences/shared/modules/controllers'\n], function (controllers) {\n  controllers.controller('LeaveRequestCtrl', LeaveRequestCtrl);\n\n  LeaveRequestCtrl.$inject = ['$log', '$q', 'parentCtrl'];\n\n  function LeaveRequestCtrl ($log, $q, parentCtrl) {\n    $log.debug('LeaveRequestCtrl');\n\n    var vm = parentCtrl;\n\n    vm.checkSubmitConditions = checkSubmitConditions;\n    vm.initChildController = initChildController;\n\n    /**\n     * Checks if submit button can be enabled for user and returns true if successful\n     *\n     * @return {Boolean}\n     */\n    function checkSubmitConditions () {\n      return vm._canCalculateChange();\n    }\n\n    /**\n     * Initialize the controller\n     *\n     * @return {Promise}\n     */\n    function initChildController () {\n      return $q.resolve();\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/leave-request.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/sick-request.controller',[\n  'common/lodash',\n  'leave-absences/shared/modules/controllers'\n], function (_, controllers) {\n  controllers.controller('SicknessRequestCtrl', SicknessRequestCtrl);\n\n  SicknessRequestCtrl.$inject = ['$log', '$q', 'api.optionGroup', 'parentCtrl'];\n\n  function SicknessRequestCtrl ($log, $q, OptionGroup, parentCtrl) {\n    $log.debug('SicknessRequestCtrl');\n    var vm = parentCtrl;\n\n    vm.checkSubmitConditions = checkSubmitConditions;\n    vm.isChecked = isChecked;\n    vm.isDocumentInRequest = isDocumentInRequest;\n\n    vm.initChildController = initChildController;\n\n    /**\n     * Checks if submit button can be enabled for user and returns true if successful\n     *\n     * @return {Boolean}\n     */\n    function checkSubmitConditions () {\n      return vm._canCalculateChange() && vm.request.sickness_reason;\n    }\n\n    /**\n     * Initialize the controller\n     *\n     * @return {Promise}\n     */\n    function initChildController () {\n      return $q.all([\n        loadDocuments(),\n        loadReasons()\n      ]);\n    }\n\n    /**\n     * During initialization it will check if given value is set for leave request list\n     * of document value ie., field sickness_required_documents in existing leave request\n     *\n     * @param {String} value\n     * @return {Boolean}\n     */\n    function isChecked (value) {\n      var docsArray = vm.request.getDocumentArray();\n\n      return !!_.find(docsArray, function (document) {\n        return document === value;\n      });\n    }\n\n    /**\n     * Checks if given value is set for leave request list of document value\n     * i.e. field sickness_required_documents\n     *\n     * @param {String} value\n     * @return {Boolean}\n     */\n    function isDocumentInRequest (value) {\n      return !!_.find(vm.sicknessDocumentTypes, function (document) {\n        return document.value === value;\n      });\n    }\n\n    /**\n     * Initializes leave request documents types required for submission\n     *\n     * @return {Promise}\n     */\n    function loadDocuments () {\n      return OptionGroup.valuesOf('hrleaveandabsences_leave_request_required_document')\n        .then(function (documentTypes) {\n          vm.sicknessDocumentTypes = documentTypes;\n        });\n    }\n\n    /**\n     * Initializes leave request reasons and indexes them by name like accident etc.,\n     *\n     * @return {Promise}\n     */\n    function loadReasons () {\n      return OptionGroup.valuesOf('hrleaveandabsences_sickness_reason')\n        .then(function (reasons) {\n          vm.sicknessReasons = _.indexBy(reasons, 'name');\n        });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/sick-request.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/sub-controllers/toil-request.controller',[\n  'common/lodash',\n  'leave-absences/shared/modules/controllers'\n], function (_, controllers) {\n  controllers.controller('ToilRequestCtrl', ToilRequestCtrl);\n\n  ToilRequestCtrl.$inject = ['$log', '$q', 'api.optionGroup', 'AbsenceType', 'parentCtrl'];\n\n  function ToilRequestCtrl ($log, $q, OptionGroup, AbsenceType, parentCtrl) {\n    $log.debug('ToilRequestCtrl');\n\n    var vm = parentCtrl;\n\n    vm.requestCanExpire = true;\n\n    vm.calculateBalanceChange = calculateBalanceChange;\n    vm.calculateToilExpiryDate = calculateToilExpiryDate;\n    vm.checkSubmitConditions = checkSubmitConditions;\n    vm.changeInNoOfDays = changeInNoOfDays;\n    vm.clearExpiryDate = clearExpiryDate;\n    vm.initChildController = initChildController;\n    vm.loadAbsencePeriodDatesTypes = loadAbsencePeriodDatesTypes;\n    vm.updateAbsencePeriodDatesTypes = updateAbsencePeriodDatesTypes;\n    vm.updateExpiryDate = updateExpiryDate;\n\n    /**\n     * Calculate change in balance, it updates balance variables.\n     * It overrides the parent's implementation\n     *\n     * @return {Promise} empty promise if all required params are not set otherwise promise from server\n     */\n    function calculateBalanceChange () {\n      if (vm.request.toil_to_accrue) {\n        vm.loading.showBalanceChange = true;\n        vm._setDateAndTypes();\n        vm.balance.change.amount = +vm.request.toil_to_accrue;\n        vm._calculateOpeningAndClosingBalance();\n        vm.uiOptions.showBalance = true;\n        vm.request.to_date_type = vm.request.from_date_type = '1';\n        vm.loading.showBalanceChange = false;\n      }\n    }\n\n    /**\n     * Calculates toil expiry date.\n     *\n     * @return {Promise}\n     */\n    function calculateToilExpiryDate () {\n      /**\n       * blocks the expiry date from updating if this is an existing request\n       * and user is not a manager or admin.\n       */\n      if (!vm.canManage && vm.request.id) {\n        return $q.resolve(vm.request.toil_expiry_date);\n      }\n\n      /**\n       * skips calculation of expiration date if request never expires\n       * according to admin setting.\n       */\n      if (!vm.requestCanExpire) {\n        vm.request.toil_expiry_date = false;\n        return $q.resolve(false);\n      }\n\n      return getReferenceDate().catch(function (errors) {\n        if (errors.length) vm.errors = errors;\n        return $q.reject(errors);\n      }).then(function (referenceDate) {\n        return AbsenceType.calculateToilExpiryDate(\n          vm.request.type_id,\n          referenceDate\n        );\n      })\n      .then(function (expiryDate) {\n        vm.request.toil_expiry_date = expiryDate;\n        vm.uiOptions.expiryDate = new Date(expiryDate);\n\n        return expiryDate;\n      });\n    }\n\n    /**\n     * Determines if the expiry date can be calculated based on the\n     * Number Of Days selected and the corresponding date field has value.\n     *\n     * @return {Boolean}\n     */\n    function canCalculateExpiryDate () {\n      return (vm.uiOptions.multipleDays && vm.request.to_date) ||\n        (!vm.uiOptions.multipleDays && vm.request.from_date);\n    }\n\n    /**\n     * Checks if submit button can be enabled for user and returns true if successful\n     *\n     * @return {Boolean}\n     */\n    function checkSubmitConditions () {\n      return !!vm.request.from_date && !!vm.request.to_date &&\n        !!vm.request.toil_duration && !!vm.request.toil_to_accrue;\n    }\n\n    /**\n     * Extends parent method. Fires calculation of expiry date when the\n     * number of days changes and the expiry date can be calculated.\n     */\n    function changeInNoOfDays () {\n      vm._reset();\n      vm._calculateOpeningAndClosingBalance();\n\n      if (canCalculateExpiryDate()) {\n        vm.calculateToilExpiryDate();\n      }\n    }\n\n    /**\n     * Clears the request's expiry date and the UI expiry date picker.\n     */\n    function clearExpiryDate () {\n      vm.request.toil_expiry_date = false;\n      vm.uiOptions.expiryDate = null;\n    }\n\n    /**\n     * Returns a promise with a date that can be used to calculate the expiry\n     * date. This date depends on the Multiple Days or Single Day options.\n     *\n     * @return {Promise}\n     */\n    function getReferenceDate () {\n      if (vm.uiOptions.multipleDays) {\n        return getReferenceDateForField({\n          hasErrors: !vm.request.to_date && !vm.request.from_date,\n          label: 'To Date',\n          value: vm.request.to_date\n        });\n      } else {\n        return getReferenceDateForField({\n          hasErrors: !vm.request.from_date,\n          label: 'From Date',\n          value: vm.request.from_date\n        });\n      }\n    }\n\n    /**\n     * Returns a reference date using the field object as source.\n     * If the field has errors, it returns an error message.\n     * If the field has no value, it returns an empty message since it still\n     * is in the process of inserting values.\n     * And if everything is ok it returns the field's date value.\n     *\n     * @return {Promise}\n     */\n    function getReferenceDateForField (field) {\n      if (field.hasErrors) {\n        var message = 'Please select ' + field.label + ' to find expiry date';\n        return $q.reject([message]);\n      }\n\n      if (!field.value) {\n        return $q.reject([]);\n      } else {\n        return $q.resolve(field.value);\n      }\n    }\n\n    /**\n     * Initialize the controller\n     *\n     * @return {Promise}\n     */\n    function initChildController () {\n      vm.request.to_date_type = vm.request.from_date_type = '1';\n\n      return initRequestCanExpire()\n        .then(function () {\n          initExpiryDate();\n\n          return loadToilAmounts();\n        });\n    }\n\n    /**\n     * Initialize expiryDate on UI from server's toil_expiry_date\n     */\n    function initExpiryDate () {\n      if (vm.canManage) {\n        vm.uiOptions.expiryDate = vm._convertDateFormatFromServer(vm.request.toil_expiry_date);\n      }\n    }\n\n    /**\n     * Initialize requestCanExpire according to admin setting\n     * and request type.\n     * @return {Promise}\n     */\n    function initRequestCanExpire () {\n      return AbsenceType.canExpire(vm.request.type_id)\n      .then(function (canExpire) {\n        vm.requestCanExpire = canExpire;\n      });\n    }\n\n    /**\n     * Overwrites the parent funtion. Inits UI values, and loads absence types\n     * and calendar.\n     *\n     * @param {Date} date - the selected date\n     * @return {Promise}\n     */\n    function loadAbsencePeriodDatesTypes (date) {\n      var oldPeriodId = vm.period.id;\n\n      return vm._checkAndSetAbsencePeriod(date)\n        .then(function () {\n          var isInCurrentPeriod = oldPeriodId === vm.period.id;\n\n          if (!isInCurrentPeriod) {\n            if (vm.uiOptions.multipleDays) {\n              vm.uiOptions.showBalance = false;\n              vm.uiOptions.toDate = null;\n              vm.request.to_date = null;\n            }\n\n            return $q.all([\n              vm._loadAbsenceTypes(),\n              vm._loadCalendar()\n            ]);\n          }\n        });\n    }\n\n    /**\n     * Initializes leave request toil amounts\n     *\n     * @return {Promise}\n     */\n    function loadToilAmounts () {\n      return OptionGroup.valuesOf('hrleaveandabsences_toil_amounts')\n        .then(function (amounts) {\n          vm.toilAmounts = _.indexBy(amounts, 'value');\n        });\n    }\n\n    /**\n     * Overwrites the parent function. It calculates the expiry date when\n     * the `from` or `to` date change value.\n     *\n     * @param {Date} date - the selected date\n     * @return {Promise}\n     */\n    function updateAbsencePeriodDatesTypes (date) {\n      return vm.loadAbsencePeriodDatesTypes(date)\n        .then(function () {\n          vm._setMinMaxDate();\n          vm._setDates();\n          vm.updateBalance();\n          vm.calculateToilExpiryDate();\n        })\n        .catch(function (error) {\n          vm.errors = [error];\n        });\n    }\n\n    /**\n     * Updates expiry date when user changes it on ui\n     */\n    function updateExpiryDate () {\n      if (vm.uiOptions.expiryDate) {\n        vm.request.toil_expiry_date = vm._convertDateToServerFormat(vm.uiOptions.expiryDate);\n      }\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/sub-controllers/toil-request.controller.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/modules/services',[\n  'common/angular',\n  'common/modules/services'\n], function (angular) {\n  'use strict';\n\n  return angular.module('leave-absences.services', [\n    'common.services'\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/modules/services.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/absence-period.instance',[\n  'leave-absences/shared/modules/models-instances',\n  'common/moment',\n  'common/models/instances/instance',\n  'common/services/hr-settings'\n], function (instances, moment) {\n  'use strict';\n\n  instances.factory('AbsencePeriodInstance', ['$log', 'ModelInstance', 'HR_settings',\n    function ($log, ModelInstance, HRSettings) {\n      $log.debug('AbsencePeriodInstance');\n\n      return ModelInstance.extend({\n        /**\n         * Returns the default custom data (as in, not given by the API)\n         * with its default values\n         *\n         * @return {object}\n         */\n        defaultCustomData: function () {\n          return {\n            current: false\n          };\n        },\n        /**\n         * Sets the current property of this absence period on instantiation.\n         *\n         * @return {object} updated attributes object\n         */\n        transformAttributes: function (attributes) {\n          var today = moment();\n          attributes.current = false;\n\n          if (moment(attributes.start_date).isSameOrBefore(today, 'day') &&\n            moment(attributes.end_date).isSameOrAfter(today, 'day')) {\n            attributes.current = true;\n          }\n\n          return attributes;\n        },\n        /**\n         *  Finds out if given date is in this object's absence period.\n         *\n         * @param  {Date} whichDate given date either as Date object or its string representation\n         * @return true if whichDate is in this instance's period range, else false\n         */\n        isInPeriod: function (whichDate) {\n          var dateFormat = HRSettings.DATE_FORMAT.toUpperCase();\n          var checkDate = moment(whichDate, dateFormat);\n\n          return moment(this.start_date).isSameOrBefore(checkDate) &&\n            moment(this.end_date).isSameOrAfter(checkDate);\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/absence-period.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/absence-period.api',[\n  'leave-absences/shared/modules/apis',\n  'common/services/api'\n], function (apis) {\n  'use strict';\n\n  apis.factory('AbsencePeriodAPI', ['$log', 'api', function ($log, api) {\n    $log.debug('AbsencePeriodAPI');\n\n    return api.extend({\n      /**\n       * This method returns all the AbsencePeriods.\n       *\n       * @param  {Object} params  matches the api endpoint params (title, start_date, end_date etc)\n       * @return {Promise}\n       */\n      all: function (params) {\n        $log.debug('AbsencePeriodAPI');\n\n        return this.sendGET('AbsencePeriod', 'get', params)\n          .then(function (data) {\n            return data.values;\n          });\n      }\n    });\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/absence-period.api.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/absence-period.model',[\n  'leave-absences/shared/modules/models',\n  'common/moment',\n  'leave-absences/shared/modules/shared-settings',\n  'leave-absences/shared/instances/absence-period.instance',\n  'leave-absences/shared/apis/absence-period.api',\n  'common/models/model',\n  'common/services/hr-settings'\n], function (models, moment) {\n  'use strict';\n\n  models.factory('AbsencePeriod', [\n    '$log', 'Model', 'AbsencePeriodAPI', 'AbsencePeriodInstance', 'shared-settings',\n    function ($log, Model, absencePeriodAPI, instance, sharedSettings) {\n      $log.debug('AbsencePeriod');\n\n      return Model.extend({\n        /**\n         * Calls the all() method of the AbsencePeriod API, and returns an\n         * AbsencePeriodInstance for each absencePeriod.\n         *\n         * @param  {Object} params  matches the api endpoint params (title, start_date, end_date etc)\n         * @return {Promise}\n         */\n        all: function (params) {\n          return absencePeriodAPI.all(params)\n            .then(function (absencePeriods) {\n              return absencePeriods.map(function (absencePeriod) {\n                return instance.init(absencePeriod, true);\n              });\n            });\n        },\n        /**\n         *  Finds out if current date is in any absence period.\n         *  If found then return absence period instance of it.\n         *\n         * @return {Object} Absence period instance or null if not found\n         */\n        current: function () {\n          var today = moment().format(sharedSettings.serverDateFormat);\n\n          var params = {\n            'start_date': {\n              '<=': today\n            },\n            'end_date': {\n              '>=': today\n            }\n          };\n\n          return absencePeriodAPI.all(params)\n            .then(function (absencePeriods) {\n              if (absencePeriods && absencePeriods.length) {\n                return instance.init(absencePeriods[0], true);\n              }\n\n              return null;\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/absence-period.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/apis/public-holiday.api',[\n  'leave-absences/shared/modules/apis',\n  'common/services/api'\n], function (apis) {\n  'use strict';\n\n  apis.factory('PublicHolidayAPI', ['$log', 'api', function ($log, api) {\n    $log.debug('PublicHolidayAPI');\n\n    return api.extend({\n      /**\n       * This method returns all the PublicHolidays.\n       *\n       * @param  {Object} params  matches the api endpoint params (title, date etc)\n       * @return {Promise}\n       */\n      all: function (params) {\n        $log.debug('PublicHolidayAPI');\n\n        return this.sendGET('PublicHoliday', 'get', params)\n          .then(function (data) {\n            return data.values;\n          });\n      }\n    });\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/apis/public-holiday.api.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/public-holiday.instance',[\n  'leave-absences/shared/modules/models-instances',\n  'common/models/instances/instance'\n], function (instances) {\n  'use strict';\n\n  instances.factory('PublicHolidayInstance', ['$log', 'ModelInstance', function ($log, ModelInstance) {\n    $log.debug('PublicHolidayInstance');\n\n    return ModelInstance.extend({});\n  }]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/public-holiday.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/models/public-holiday.model',[\n  'common/moment',\n  'leave-absences/shared/modules/models',\n  'common/models/model',\n  'common/services/hr-settings',\n  'leave-absences/shared/apis/public-holiday.api',\n  'leave-absences/shared/instances/public-holiday.instance'\n], function (moment, models) {\n  'use strict';\n\n  models.factory('PublicHoliday', [\n    '$log', 'Model', 'PublicHolidayAPI', 'PublicHolidayInstance', 'shared-settings',\n    function ($log, Model, publicHolidayAPI, instance, sharedSettings) {\n      $log.debug('PublicHoliday');\n\n      return Model.extend({\n        /**\n         * Calls the all() method of the PublicHoliday API, and returns an\n         * PublicHolidayInstance for each public holiday.\n         *\n         * @param  {Object} params  matches the api endpoint params (title, date etc)\n         * @return {Promise}\n         */\n        all: function (params) {\n          $log.debug('PublicHoliday.all', params);\n\n          return publicHolidayAPI.all(params)\n            .then(function (publicHolidays) {\n              return publicHolidays.map(function (publicHoliday) {\n                return instance.init(publicHoliday, true);\n              });\n            });\n        },\n        /**\n         *  Finds out if given date is a public holiday.\n         *\n         * @param  {Date} whichDate given date either as Date object or its string representation\n         * @return {Bool} returns true if date is a public holday else false\n         */\n        isPublicHoliday: function (whichDate) {\n          $log.debug('PublicHoliday.isPublicHoliday', whichDate);\n\n          var checkDate = moment(whichDate).format(sharedSettings.serverDateFormat);\n          var params = {\n            'date': checkDate\n          };\n\n          return publicHolidayAPI.all(params)\n            .then(function (publicHolidays) {\n              return !!publicHolidays.length;\n            });\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/models/public-holiday.model.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/sickness-request.instance',[\n  'common/lodash',\n  'leave-absences/shared/modules/models-instances',\n  'leave-absences/shared/instances/leave-request.instance'\n], function (_, modelInstances) {\n  'use strict';\n\n  modelInstances.factory('SicknessRequestInstance', [\n    'LeaveRequestAPI',\n    'LeaveRequestInstance',\n    function (LeaveRequestAPI, LeaveRequestInstance) {\n      return LeaveRequestInstance.extend({\n\n        /**\n         * Returns the default custom data\n         * with its default values\n         *\n         * @return {object}\n         */\n        defaultCustomData: function () {\n          var sicknessCustomData = {\n            sickness_reason: null,\n            sickness_required_documents: '',\n            request_type: 'sickness'\n          };\n\n          return _.assign({}, LeaveRequestInstance.defaultCustomData(), sicknessCustomData);\n        },\n\n        /**\n         * Gets array of documents from comma separated string of documents\n         *\n         * @return {Array}\n         */\n        getDocumentArray: function () {\n          var docsArray = this.sickness_required_documents ? this.sickness_required_documents.split(',') : [];\n\n          return docsArray;\n        },\n\n        /**\n         * Checks if given value is added for leave request list of document value ie., field required_documents\n         *  otherwise add it to list of required documents (list is actually string of comma separated values for now)\n         *\n         * @param {String} documentValue required document value like '1'\n         */\n        toggleDocument: function (documentValue) {\n          var docsArray = this.getDocumentArray();\n          var index = docsArray.indexOf(documentValue);\n\n          _.contains(docsArray, documentValue) ? docsArray.splice(index, 1) : docsArray.push(documentValue);\n          this.sickness_required_documents = docsArray.join(',');\n        },\n\n        /**\n         * Override of parent method\n         *\n         * @param {object} result - The accumulator object\n         * @param {string} key - The property name\n         */\n        toAPIFilter: function (result, __, key) {\n          if (!_.includes(['balance_change', 'dates', 'comments', 'files'], key)) {\n            result[key] = this[key];\n          }\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/sickness-request.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/instances/toil-request.instance',[\n  'common/lodash',\n  'leave-absences/shared/modules/models-instances',\n  'leave-absences/shared/instances/leave-request.instance'\n], function (_, modelInstances) {\n  'use strict';\n\n  modelInstances.factory('TOILRequestInstance', [\n    'LeaveRequestAPI',\n    'LeaveRequestInstance',\n    function (LeaveRequestAPI, LeaveRequestInstance) {\n      return LeaveRequestInstance.extend({\n\n        /**\n         * Returns the default custom data (as in, not given by the API)\n         * with its default values\n         *\n         * @return {object}\n         */\n        defaultCustomData: function () {\n          var toilCustomData = {\n            toilDurationHours: '0',\n            toilDurationMinutes: '0',\n            request_type: 'toil'\n          };\n\n          return _.assign({}, LeaveRequestInstance.defaultCustomData(), toilCustomData);\n        },\n\n        /**\n         * Sets the duration hours and minutes from toil_duration on instantiation.\n         *\n         * @param {Object} attributes that need to be transformed\n         * @return {Object} updated attributes object\n         */\n        transformAttributes: function (attributes) {\n          var duration = Number(attributes.toil_duration);\n          if (duration) {\n            attributes.toilDurationHours = Math.floor(duration / 60).toString();\n            attributes.toilDurationMinutes = (duration % 60).toString();\n          }\n\n          return attributes;\n        },\n\n        /**\n         * Update duration\n         */\n        updateDuration: function () {\n          this.toil_duration = Number(this.toilDurationHours) * 60 + Number(this.toilDurationMinutes);\n        },\n\n        /**\n         * Override of parent method\n         *\n         * @param {object} result - The accumulator object\n         * @param {string} key - The property name\n         */\n        toAPIFilter: function (result, __, key) {\n          if (!_.includes(['balance_change', 'dates', 'comments', 'files', 'toilDurationHours', 'toilDurationMinutes'], key)) {\n            result[key] = this[key];\n          }\n        }\n      });\n    }\n  ]);\n});\n\n//# sourceURL=/leave-absences/shared/instances/toil-request.instance.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/controllers/request.controller',[\n  'common/angular',\n  'leave-absences/shared/modules/controllers',\n  'common/lodash',\n  'common/moment',\n  'common/models/contact',\n  'common/models/session.model',\n  'common/services/api/option-group',\n  'common/services/hr-settings',\n  'common/services/pub-sub',\n  'leave-absences/shared/models/absence-period.model',\n  'leave-absences/shared/models/absence-type.model',\n  'leave-absences/shared/models/entitlement.model',\n  'leave-absences/shared/models/leave-request.model',\n  'leave-absences/shared/models/public-holiday.model',\n  'leave-absences/shared/instances/leave-request.instance',\n  'leave-absences/shared/instances/sickness-request.instance',\n  'leave-absences/shared/instances/toil-request.instance'\n], function (angular, controllers, _) {\n  'use strict';\n\n  controllers.controller('RequestCtrl', RequestCtrl);\n\n  RequestCtrl.$inject = ['$log', '$q', '$rootScope', '$timeout', '$uibModalInstance', 'checkPermissions',\n    'api.optionGroup', 'dialog', 'pubSub', 'directiveOptions', 'Contact', 'Session', 'AbsencePeriod',\n    'AbsenceType', 'Entitlement', 'LeaveRequestInstance', 'shared-settings', 'SicknessRequestInstance',\n    'TOILRequestInstance'];\n\n  function RequestCtrl ($log, $q, $rootScope, $timeout, $modalInstance, checkPermissions, OptionGroup, dialog,\n    pubSub, directiveOptions, Contact, Session, AbsencePeriod, AbsenceType, Entitlement,\n    LeaveRequestInstance, sharedSettings, SicknessRequestInstance, TOILRequestInstance) {\n    $log.debug('RequestCtrl');\n\n    var absenceTypesAndIds;\n    var availableStatusesMatrix = {};\n    var childComponentsCount = 0;\n    var initialLeaveRequestAttributes = {}; // used to compare the change in leaverequest in edit mode\n    var listeners = [];\n    var loggedInContactId = '';\n    var NO_ENTITLEMENT_ERROR = 'No entitlement';\n    var role = '';\n    var vm = _.assign(this, directiveOptions); // put all directive options directly in the vm\n\n    vm.absencePeriods = [];\n    vm.absenceTypes = [];\n    vm.canManage = false; // vm flag is set on initialisation of the controller\n    vm.contactName = null; // contact name of the owner of leave request\n    vm.errors = [];\n    vm.fileUploader = null;\n    vm.staffMemberSelectionComplete = false;\n    vm.loading = { absenceTypes: true };\n    vm.managedContacts = [];\n    vm.mode = ''; // can be edit, create, view\n    vm.newStatusOnSave = null;\n    vm.period = {};\n    vm.postContactSelection = false; // flag to track if user is selected for enabling UI\n    vm.requestStatuses = {};\n    vm.selectedAbsenceType = {};\n    vm.submitting = false;\n    vm.balance = {\n      closing: 0,\n      opening: 0,\n      change: {\n        amount: 0,\n        breakdown: []\n      }\n    };\n\n    vm.canSubmit = canSubmit;\n    vm.closeAlert = closeAlert;\n    vm.deleteLeaveRequest = deleteLeaveRequest;\n    vm.dismissModal = dismissModal;\n    vm.getStatuses = getStatuses;\n    vm.getStatusFromValue = getStatusFromValue;\n    vm.initAfterContactSelection = initAfterContactSelection;\n    vm.initRequestAttributes = initRequestAttributes;\n    vm.isLeaveStatus = isLeaveStatus;\n    vm.isLeaveType = isLeaveType;\n    vm.isMode = isMode;\n    vm.isRole = isRole;\n    vm.submit = submit;\n    vm.updateBalance = updateBalance;\n    vm._loadAbsenceTypes = _loadAbsenceTypes;\n\n    /**\n     * Initializes the controller on loading the dialog\n     *\n     * @return {Promise}\n     */\n    (function init () {\n      vm.loading.absenceTypes = true;\n\n      initAvailableStatusesMatrix();\n      initListeners();\n\n      return $q.all([\n        loadLoggedInContactId(),\n        initRoles(),\n        loadAbsencePeriods(),\n        loadStatuses()\n      ]).then(function () {\n        return $q.all([\n          initAbsencePeriod(),\n          initRequest()\n        ]);\n      })\n      .then(function () {\n        initOpenMode();\n\n        return vm.canManage && !vm.isMode('edit') && loadManagees();\n      })\n      .then(function () {\n        if (vm.selectedContactId) {\n          vm.request.contact_id = vm.selectedContactId;\n        }\n        // The additional check here prevents error being displayed on startup when no contact is selected\n        if (vm.request.contact_id) {\n          return vm.initAfterContactSelection();\n        }\n      })\n      .catch(handleError)\n      .finally(function () {\n        vm.loading.absenceTypes = false;\n      });\n    }());\n\n    /**\n     * Broadcasts an event when request has been updated from awaiting approval status to something else\n     */\n    function broadcastRequestUpdatedEvent () {\n      var awaitingApprovalStatusValue = vm.requestStatuses[sharedSettings.statusNames.awaitingApproval].value;\n\n      // Check if the leave request had awaiting approval status before update,\n      // and after update the status is not awaiting approval\n      if (initialLeaveRequestAttributes.status_id === awaitingApprovalStatusValue &&\n        awaitingApprovalStatusValue !== vm.request.status_id) {\n        pubSub.publish('ManagerBadge:: Update Count');\n      }\n    }\n\n    /**\n     * Checks if submit button can be enabled for user and returns true if succeeds\n     *\n     * @return {Boolean}\n     */\n    function canSubmit () {\n      var canSubmit = vm.checkSubmitConditions ? vm.checkSubmitConditions() : false;\n\n      // check if user has changed any attribute\n      if (vm.isMode('edit')) {\n        canSubmit = canSubmit && hasRequestChanged();\n      }\n\n      // check if manager has changed status\n      if (vm.canManage && vm.requestStatuses) {\n        // awaiting_approval will not be available in vm.requestStatuses if manager has changed selection\n        canSubmit = canSubmit && !!vm.getStatusFromValue(vm.newStatusOnSave);\n      }\n\n      // check if the selected date period is in absence period\n      canSubmit = canSubmit && !!vm.period.id;\n\n      // check if the absence types are present\n      canSubmit = canSubmit && !!vm.absenceTypes.length;\n\n      return canSubmit && !vm.isMode('view');\n    }\n\n    /**\n     * Changes status of the leave request before saving it\n     * When recording for yourself the status_id should be always set to awaitingApproval before saving\n     * If manager or admin have changed the status through dropdown, assign the same before calling API\n     */\n    function changeStatusBeforeSave () {\n      if (vm.isSelfRecord) {\n        vm.request.status_id = vm.requestStatuses[sharedSettings.statusNames.awaitingApproval].value;\n      } else if (vm.canManage) {\n        vm.request.status_id = vm.newStatusOnSave || vm.request.status_id;\n      }\n    }\n\n    /**\n     * Checks if the balance change has changed since this leave request was saved\n     *\n     * @return {Promise}\n     */\n    function checkIfBalanceChangeHasChanged () {\n      if (!vm.isMode('edit') || vm.isRole('staff') || getLeaveType() === 'toil') { return; }\n\n      return vm.request.calculateBalanceChange()\n        .then(function (balanceChange) {\n          if (+vm.balance.change.amount !== +balanceChange.amount) {\n            promptBalanceChangeRecalculation(balanceChange);\n\n            return $q.reject();\n          }\n        });\n    }\n\n    /**\n     * Closes the error alerts if any\n     */\n    function closeAlert () {\n      vm.errors = [];\n    }\n\n    /**\n     * Validates and creates the leave request\n     *\n     * @returns {Promise}\n     */\n    function createRequest () {\n      return vm.request.create()\n        .then(triggerChildComponentsSubmitAndWaitForResponse)\n        .then(function () {\n          postSubmit('LeaveRequest::new');\n        });\n    }\n\n    /**\n     * Sets the \"change_balance\" attribute to the leave request\n     * if a force balance change recalculation is needed\n     */\n    function decideIfBalanceChangeNeedsAForceRecalculation () {\n      if (!vm.isRole('staff')) {\n        vm.request.change_balance = true;\n      }\n    }\n\n    /**\n     * Deletes the leave request\n     */\n    function deleteLeaveRequest () {\n      dialog.open({\n        title: 'Confirm Deletion?',\n        copyCancel: 'Cancel',\n        copyConfirm: 'Confirm',\n        classConfirm: 'btn-danger',\n        msg: 'This cannot be undone',\n        onConfirm: function () {\n          return vm.request.delete()\n            .then(function () {\n              vm.dismissModal();\n              pubSub.publish('LeaveRequest::deleted', vm.request);\n            });\n        }\n      });\n    }\n\n    /**\n     * Close the modal\n     */\n    function dismissModal () {\n      $modalInstance.dismiss({\n        $value: 'cancel'\n      });\n    }\n\n    /**\n     * Returns the parameters for to load Absence Type of selected leave type\n     *\n     * @return {Object}\n     */\n    function getAbsenceTypeParams () {\n      var leaveType = getLeaveType();\n\n      if (leaveType === 'leave') {\n        return { is_sick: false };\n      } else if (leaveType === 'sickness') {\n        return { is_sick: true };\n      } else if (leaveType === 'toil') {\n        return { allow_accruals_request: true };\n      }\n    }\n\n    /**\n     * Helper functions to get available statuses depending on the\n     * current request status value.\n     *\n     * @return {Array}\n     */\n    function getAvailableStatusesForCurrentStatus () {\n      var currentStatus = vm.getStatusFromValue(vm.request.status_id);\n\n      return getAvailableStatusesForStatusName(currentStatus.name);\n    }\n\n    /**\n     * Helper function that returns an array of the statuses available\n     * for a specific status name.\n     *\n     * @return {Array}\n     */\n    function getAvailableStatusesForStatusName (statusName) {\n      return _.map(availableStatusesMatrix[statusName], function (status) {\n        return vm.requestStatuses[status];\n      });\n    }\n\n    /**\n     * Gets leave type.\n     *\n     * @return {String} leave type\n     */\n    function getLeaveType () {\n      return vm.request ? vm.request.request_type : (vm.leaveType || null);\n    }\n\n    /**\n     * Gets currently selected absence type from leave request type_id\n     *\n     * @return {Object} absence type object\n     */\n    function getSelectedAbsenceType () {\n      return _.find(vm.absenceTypes, function (absenceType) {\n        return absenceType.id === vm.request.type_id;\n      });\n    }\n\n    /**\n     * Returns an array of statuses depending on the previous status value\n     * This is used to populate the dropdown with array of statuses.\n     *\n     * @return {Array}\n     */\n    function getStatuses () {\n      if (!vm.request || angular.equals({}, vm.requestStatuses)) {\n        return [];\n      }\n\n      if (!vm.request.status_id) {\n        return getAvailableStatusesForStatusName('none');\n      }\n\n      return getAvailableStatusesForCurrentStatus();\n    }\n\n    /**\n     * Gets status object for given status value\n     *\n     * @param {String} value - value of the status\n     * @return {Object} option group of type status or undefined if not found\n     */\n    function getStatusFromValue (value) {\n      return _.find(vm.requestStatuses, function (status) {\n        return status.value === value;\n      });\n    }\n\n    /**\n     * Handles errors\n     *\n     * @param {Array|Object}\n     */\n    function handleError (errors) {\n      vm.errors = _.isArray(errors) ? errors : [errors];\n      vm.loading.absenceTypes = false;\n      vm.submitting = false;\n    }\n\n    /**\n     * Checks if a leave request has been changed since opening the modal\n     *\n     * @return {Boolean}\n     */\n    function hasRequestChanged () {\n      // using angular.equals to automatically ignore the $$hashkey property\n      return !angular.equals(\n          initialLeaveRequestAttributes,\n          vm.request.attributes()\n        ) || (vm.fileUploader && vm.fileUploader.queue.length !== 0) ||\n        (vm.canManage && vm.newStatusOnSave);\n    }\n\n    /**\n     * Inits absence period for the current date\n     */\n    function initAbsencePeriod () {\n      vm.period = _.find(vm.absencePeriods, function (period) {\n        return period.current;\n      });\n    }\n\n    /**\n     * Initializes after contact is selected either directly or by manager\n     *\n     * @return {Promise}\n     */\n    function initAfterContactSelection () {\n      vm.postContactSelection = true;\n\n      // when manager deselects contact it is called without a selected contact_id\n      if (!vm.request.contact_id) {\n        return $q.reject('The contact id was not set');\n      }\n\n      return $q.all([\n        vm._loadAbsenceTypes()\n      ])\n      .then(function () {\n        setInitialAbsenceTypes();\n        initStatus();\n        initContact();\n\n        if (vm.isMode('edit')) {\n          setInitialAttributes();\n        }\n\n        vm.postContactSelection = false;\n        vm.staffMemberSelectionComplete = true;\n      })\n      .catch(function (error) {\n        if (error !== NO_ENTITLEMENT_ERROR) {\n          return $q.reject(error);\n        }\n      });\n    }\n\n    /**\n     * Initialize available statuses matrix\n     */\n    function initAvailableStatusesMatrix () {\n      var defaultStatuses = [\n        sharedSettings.statusNames.moreInformationRequired,\n        sharedSettings.statusNames.approved,\n        sharedSettings.statusNames.rejected,\n        sharedSettings.statusNames.cancelled\n      ];\n\n      availableStatusesMatrix['none'] = [\n        sharedSettings.statusNames.moreInformationRequired,\n        sharedSettings.statusNames.approved\n      ];\n      availableStatusesMatrix['awaiting_approval'] = defaultStatuses;\n      availableStatusesMatrix['more_information_required'] = defaultStatuses;\n      availableStatusesMatrix['rejected'] = defaultStatuses;\n      availableStatusesMatrix['approved'] = defaultStatuses;\n      availableStatusesMatrix['cancelled'] = [\n        sharedSettings.statusNames.awaitingApproval\n      ].concat(defaultStatuses);\n    }\n\n    /**\n     * Initialize contact\n     *\n     * {Promise}\n     */\n    function initContact () {\n      if (vm.canManage) {\n        return Contact.find(vm.request.contact_id)\n          .then(function (contact) {\n            vm.contactName = contact.display_name;\n          });\n      }\n\n      return $q.resolve();\n    }\n\n    /**\n     * Initialises listeners\n     */\n    function initListeners () {\n      listeners.push(\n        $rootScope.$on('LeaveRequestPopup::requestObjectUpdated', setInitialAttributes),\n        $rootScope.$on('LeaveRequestPopup::handleError', function (__, errors) { handleError(errors); }),\n        $rootScope.$on('LeaveRequestPopup::childComponent::register', function () { childComponentsCount++; }),\n        $rootScope.$on('LeaveRequestPopup::loadAbsenceTypes', reloadAbsenceTypes)\n      );\n    }\n\n    /**\n     * Initialises open mode of the dialog\n     */\n    function initOpenMode () {\n      var viewModeStatuses;\n\n      if (vm.request.id) {\n        viewModeStatuses = [\n          vm.requestStatuses[sharedSettings.statusNames.approved].value,\n          vm.requestStatuses[sharedSettings.statusNames.adminApproved].value,\n          vm.requestStatuses[sharedSettings.statusNames.rejected].value,\n          vm.requestStatuses[sharedSettings.statusNames.cancelled].value\n        ];\n        vm.mode = 'edit';\n\n        if (vm.isRole('staff') && viewModeStatuses.indexOf(vm.request.status_id) > -1) {\n          vm.mode = 'view';\n        }\n      } else {\n        vm.mode = 'create';\n      }\n    }\n\n    /**\n     * Initializes the leave request object\n     */\n    function initRequest () {\n      var leaveType, attributes;\n\n      vm.request = vm.leaveRequest || null;\n      leaveType = getLeaveType();\n      attributes = vm.initRequestAttributes();\n\n      if (leaveType === 'leave') {\n        vm.request = LeaveRequestInstance.init(attributes);\n      } else if (leaveType === 'sickness') {\n        vm.request = SicknessRequestInstance.init(attributes);\n      } else if (leaveType === 'toil') {\n        vm.request = TOILRequestInstance.init(attributes);\n      }\n    }\n\n    /**\n     * Initialize request attributes based on directive\n     *\n     * @return {Object} attributes\n     */\n    function initRequestAttributes () {\n      var attributes = {};\n\n      // if set indicates self leave request is either being managed or edited\n      if (vm.request) {\n        attributes = vm.request.attributes();\n      } else if (!vm.canManage) {\n        attributes = { contact_id: loggedInContactId };\n      }\n\n      return attributes;\n    }\n\n    /**\n     * Initialises the user role to either *admin*, *manager*, or *staff*\n     * depending on the user permissions and whether they are managing their own\n     * leave or not.\n     *\n     * @return {Promise}\n     */\n    function initRoles () {\n      role = 'staff';\n\n      // If the user is creating or editing their own leave, they will be\n      // treated as a staff regardless of their actual role.\n      if ($rootScope.section === 'my-leave') {\n        return;\n      }\n\n      return checkPermissions(sharedSettings.permissions.admin.administer)\n        .then(function (isAdmin) {\n          isAdmin && (role = 'admin');\n        })\n        .then(function () {\n          // (role === 'staff') means it is not admin so need to check if manager\n          return (role === 'staff') && checkPermissions(sharedSettings.permissions.ssp.manage)\n            .then(function (isManager) {\n              isManager && (role = 'manager');\n            });\n        })\n        .finally(function () {\n          vm.canManage = vm.isRole('manager') || vm.isRole('admin');\n        });\n    }\n\n    /**\n     * Initialises status\n     */\n    function initStatus () {\n      if (vm.isRole('admin') || (vm.isMode('create') && vm.isRole('manager'))) {\n        vm.newStatusOnSave = vm.requestStatuses[sharedSettings.statusNames.approved].value;\n      }\n    }\n\n    /**\n     * Checks if the leave request has the given status\n     *\n     * @param {String} leaveStatus\n     * @return {Boolean}\n     */\n    function isLeaveStatus (leaveStatus) {\n      var status = vm.getStatusFromValue(vm.request.status_id);\n\n      return status ? status.name === leaveStatus : false;\n    }\n\n    /**\n     * Checks if popup is opened in given leave type like `leave` or `sickness` or 'toil'\n     *\n     * @param {String} leaveTypeParam to check the leave type of current request\n     * @return {Boolean}\n     */\n    function isLeaveType (leaveTypeParam) {\n      return vm.request && vm.request.request_type === leaveTypeParam;\n    }\n\n    /**\n     * Checks if popup is opened in given mode\n     *\n     * @param {String} modeParam to open leave request like edit or view or create\n     * @return {Boolean}\n     */\n    function isMode (modeParam) {\n      return vm.mode === modeParam;\n    }\n\n    /**\n     * Checks if popup is opened in given role\n     *\n     * @param {String} roleParam like manager, staff\n     * @return {Boolean}\n     */\n    function isRole (roleParam) {\n      return role === roleParam;\n    }\n\n    /**\n     * Loads all absence periods\n     */\n    function loadAbsencePeriods () {\n      return AbsencePeriod.all()\n        .then(function (periods) {\n          vm.absencePeriods = periods;\n        });\n    }\n\n    /**\n     * Loads the contact id of the currently logged in user\n     *\n     * @return {Promise}\n     */\n    function loadLoggedInContactId () {\n      return Session.get().then(function (value) {\n        loggedInContactId = value.contactId;\n      });\n    }\n\n    /**\n     * Loads the managees of currently logged in user\n     *\n     * @return {Promise}\n     */\n    function loadManagees () {\n      if (vm.selectedContactId) {\n        // In case of a pre-selected contact administration\n        return Contact.find(vm.selectedContactId)\n          .then(function (contact) {\n            vm.managedContacts = [contact];\n          });\n      } else if (vm.isRole('admin')) {\n        // In case of general administration\n        return Contact.all()\n          .then(function (contacts) {\n            vm.managedContacts = _.remove(contacts.list, function (contact) {\n              // Removes the admin from the list of contacts\n              return contact.id !== loggedInContactId;\n            });\n          });\n      } else {\n        // In any other case (including managing)\n        return Contact.find(loggedInContactId)\n          .then(function (contact) {\n            return contact.leaveManagees();\n          })\n          .then(function (contacts) {\n            vm.managedContacts = contacts;\n          });\n      }\n    }\n\n    /**\n     * Initializes leave request statuses\n     *\n     * @return {Promise}\n     */\n    function loadStatuses () {\n      return OptionGroup.valuesOf('hrleaveandabsences_leave_request_status')\n        .then(function (statuses) {\n          vm.requestStatuses = _.indexBy(statuses, 'name');\n        });\n    }\n\n    /**\n     * Maps absence types to be more compatible for UI selection\n     *\n     * @param {Array} absenceTypes\n     * @param {Object} entitlements\n     * @return {Array} of filtered absence types for given entitlements\n     */\n    function mapAbsenceTypesWithBalance (absenceTypes, entitlements) {\n      var absenceType;\n\n      return entitlements.map(function (entitlementItem) {\n        absenceType = _.find(absenceTypes, function (absenceTypeItem) {\n          return absenceTypeItem.id === entitlementItem.type_id;\n        });\n\n        return {\n          id: entitlementItem.type_id,\n          title: absenceType.title + ' ( ' + entitlementItem.remainder.current + ' ) ',\n          remainder: entitlementItem.remainder.current,\n          allow_overuse: absenceType.allow_overuse\n        };\n      });\n    }\n\n    /**\n     * Called after successful submission of leave request\n     *\n     * @param {String} eventName name of the event to emit\n     */\n    function postSubmit (eventName) {\n      broadcastRequestUpdatedEvent();\n      pubSub.publish(eventName, vm.request);\n\n      vm.errors = [];\n\n      vm.dismissModal();\n    }\n\n    /**\n     * Prompts to confirm the recalculation of the balance change via a dialog\n     */\n    function promptBalanceChangeRecalculation (balanceChange) {\n      dialog.open({\n        title: 'Recalculate Balance Change?',\n        copyCancel: 'Cancel',\n        copyConfirm: 'Yes',\n        classConfirm: 'btn-warning',\n        msg: 'The leave balance change has updated since ' +\n          'this leave request was created. ' +\n          'Do you want to recalculate the balance change?',\n        onConfirm: function () {\n          $rootScope.$emit('LeaveRequestPopup::updateBalance');\n        }\n      });\n    }\n\n    /**\n     * Reloads the absence Types and broadcasts an event to update the balance\n     *\n     * @return {Promise}\n     */\n    function reloadAbsenceTypes () {\n      return _loadAbsenceTypes()\n        .then(function () {\n          setInitialAbsenceTypes();\n          $rootScope.$emit('LeaveRequestPopup::updateBalance');\n        });\n    }\n\n    /**\n     * Sets entitlements and sets the absences type available for the user.\n     * It depends on absenceTypesAndIds to be set to list of absence types and ids\n     *\n     * @param {Object} absenceTypesAndIds contains all absencetypes and their ids\n     * @return {Promise}\n     */\n    function setAbsenceTypesFromEntitlements (absenceTypesAndIds) {\n      return Entitlement.all({\n        contact_id: vm.request.contact_id,\n        period_id: vm.period.id,\n        type_id: { IN: absenceTypesAndIds.ids }\n      }, true) // `true` because we want to use the 'future' balance for calculation\n        .then(function (entitlements) {\n          // create a list of absence types with a `balance` property\n          vm.absenceTypes = mapAbsenceTypesWithBalance(absenceTypesAndIds.types, entitlements);\n\n          if (!vm.absenceTypes.length) {\n            return $q.reject(NO_ENTITLEMENT_ERROR);\n          }\n        });\n    }\n\n    /**\n     * Set initial values to absence types when opening the popup\n     */\n    function setInitialAbsenceTypes () {\n      if (vm.isMode('create')) {\n        // Assign the first absence type to the leave request\n        vm.selectedAbsenceType = vm.absenceTypes[0];\n        vm.request.type_id = vm.selectedAbsenceType.id;\n      } else {\n        // Either View or Edit Mode\n        vm.selectedAbsenceType = getSelectedAbsenceType();\n      }\n    }\n\n    /**\n     * Set Initial attribute\n     */\n    function setInitialAttributes () {\n      initialLeaveRequestAttributes = angular.copy(vm.request.attributes());\n    }\n\n    /**\n     * Submits the form, only if the leave request is valid, also emits event\n     * to notify event subscribers about the the save.\n     * Updates request based on role and mode\n     */\n    function submit () {\n      var originalStatus = vm.request.status_id;\n\n      if (vm.isMode('view') || vm.submitting) {\n        return;\n      }\n\n      vm.submitting = true;\n\n      changeStatusBeforeSave();\n\n      return vm.request.isValid()\n        .then(checkIfBalanceChangeHasChanged)\n        .then(decideIfBalanceChangeNeedsAForceRecalculation)\n        .then(function () {\n          return vm.isMode('edit') ? updateRequest() : createRequest();\n        })\n        .catch(function (errors) {\n          // if there is an error, put back the original status\n          vm.request.status_id = originalStatus;\n          errors && handleError(errors);\n        })\n        .finally(function () {\n          vm.submitting = false;\n        });\n    }\n\n    /**\n     * Fire an event to start child processes which needs to be done after leave request is saved.\n     * Waits for the response before resolving the promise\n     *\n     * @returns {Promise}\n     */\n    function triggerChildComponentsSubmitAndWaitForResponse () {\n      var deferred = $q.defer();\n      var errors = [];\n      var responses = 0;\n\n      if (childComponentsCount > 0) {\n        $rootScope.$broadcast('LeaveRequestPopup::submit', doneCallback);\n      } else {\n        deferred.resolve();\n      }\n\n      function doneCallback (error) {\n        error && errors.push(error);\n\n        if (++responses === childComponentsCount) {\n          unsubscribeFromEvents();\n\n          errors.length > 0 ? deferred.reject(errors) : deferred.resolve();\n        }\n      }\n\n      return deferred.promise;\n    }\n\n    /**\n     * Unsubscribes from events\n     * @NOTE: Gets called when the component is destroyed\n     */\n    function unsubscribeFromEvents () {\n      // Destroy all events\n      _.forEach(listeners, function (listener) {\n        listener();\n      });\n    }\n\n    /**\n     * Validates and updates the leave request\n     *\n     * @returns {Promise}\n     */\n    function updateRequest () {\n      return vm.request.update()\n        .then(triggerChildComponentsSubmitAndWaitForResponse)\n        .then(function () {\n          if (vm.isRole('manager')) {\n            postSubmit('LeaveRequest::updatedByManager');\n          } else if (vm.isRole('staff') || vm.isRole('admin')) {\n            postSubmit('LeaveRequest::edit');\n          }\n        });\n    }\n\n    /**\n     * Broadcast an event to Update the Balance\n     */\n    function updateBalance () {\n      $rootScope.$broadcast('LeaveRequestPopup::updateBalance');\n    }\n\n    /**\n     * Initializes values for absence types and entitlements when the\n     * leave request popup model is displayed\n     *\n     * @return {Promise}\n     */\n    function _loadAbsenceTypes () {\n      return AbsenceType.all(getAbsenceTypeParams())\n        .then(function (absenceTypes) {\n          absenceTypesAndIds = {\n            types: absenceTypes,\n            ids: absenceTypes.map(function (absenceType) {\n              return absenceType.id;\n            })\n          };\n\n          return setAbsenceTypesFromEntitlements(absenceTypesAndIds);\n        });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/controllers/request.controller.js"),
eval("/* eslint-env amd */\n\ndefine('leave-absences/shared/services/leave-popup.service',[\n  'common/lodash',\n  'leave-absences/shared/modules/services',\n  'common/services/notification.service',\n  'leave-absences/shared/controllers/request.controller'\n], function (_, services) {\n  'use strict';\n\n  services.factory('LeavePopup', LeavePopupService);\n\n  LeavePopupService.$inject = [\n    '$log', '$rootElement', '$rootScope', '$uibModal', 'notificationService',\n    'shared-settings', 'DateFormat', 'Session', 'LeaveRequest'\n  ];\n\n  function LeavePopupService ($log, $rootElement, $rootScope, $modal, notification, sharedSettings, DateFormat, Session, LeaveRequest) {\n    $log.debug('LeavePopup');\n\n    return {\n      openModal: openModal,\n      openModalByID: openModalByID\n    };\n\n    /**\n     * Checks if the current logged in contact can see the leave request\n     *\n     * @return {Promise}\n     */\n    function checkPermissionBeforeOpeningPopup (leaveRequest) {\n      return Session.get()\n        .then(function (sessionData) {\n          return leaveRequest.roleOf(sessionData.contactId);\n        })\n        .then(function (role) {\n          return role !== 'none';\n        });\n    }\n\n    /**\n     * Open leave request popup for the given leave request\n     *\n     * @param {LeaveRequestInstance} leaveRequest\n     * @param {String} leaveType\n     * @param {String} selectedContactId - Contact ID for the contact dropdown\n     *                                     when the manager/admin is opening the request\n     * @param {Boolean} isSelfRecord - True If the owner is opening the leave request\n     */\n    function openModal (leaveRequest, leaveType, selectedContactId, isSelfRecord) {\n      $modal.open({\n        appendTo: $rootElement.children().eq(0),\n        templateUrl: sharedSettings.sharedPathTpl + 'components/leave-request-popup/leave-request-popup.html',\n        controller: 'RequestCtrl',\n        controllerAs: '$ctrl',\n        windowClass: 'chr_leave-request-modal',\n        resolve: {\n          directiveOptions: function () {\n            return {\n              leaveType: leaveType,\n              leaveRequest: leaveRequest,\n              selectedContactId: selectedContactId,\n              isSelfRecord: isSelfRecord\n            };\n          },\n          // to set HR_settings DateFormat\n          format: ['DateFormat', function (DateFormat) {\n            // stores the data format in HR_setting.DATE_FORMAT\n            return DateFormat.getDateFormat();\n          }]\n        }\n      });\n    }\n\n    /**\n     * Open leave request popup for a given ID\n     *\n     * @param {String} leaveRequestID\n     * @return {Promise}\n     */\n    function openModalByID (leaveRequestID) {\n      return LeaveRequest.find(leaveRequestID)\n        .then(function (leaveRequest) {\n          return checkPermissionBeforeOpeningPopup(leaveRequest)\n            .then(function (hasPermission) {\n              if (hasPermission) {\n                openModal(leaveRequest, leaveRequest.request_type, leaveRequest.contact_id, $rootScope.section === 'my-leave');\n              } else {\n                notification.error('Error', 'You dont have permission to see this leave request');\n              }\n            });\n        })\n        .catch(function (errorMsg) {\n          notification.error('Error', errorMsg);\n        });\n    }\n  }\n});\n\n//# sourceURL=/leave-absences/shared/services/leave-popup.service.js"),eval("define('leave-absences/absence-tab/modules/components',[\n  'common/angular'\n], function (angular) {\n  return angular.module('absence-tab.components', []);\n});\n\n//# sourceURL=/leave-absences/absence-tab/modules/components.js"),eval("/* eslint-env amd */\n\n(function (CRM) {\n  define('leave-absences/absence-tab/components/absence-tab-container.component',[\n    'leave-absences/absence-tab/modules/components'\n  ], function (components) {\n    components.component('absenceTabContainer', {\n      templateUrl: ['settings', function (settings) {\n        return settings.pathTpl + 'components/absence-tab-container.html';\n      }],\n      controllerAs: 'absence',\n      controller: ['$log', '$rootScope', function ($log, $rootScope) {\n        $log.debug('Component: absence-tab-container');\n\n        $rootScope.section = 'absence-tab';\n\n        var vm = this;\n\n        vm.contactId = CRM.adminId;\n      }]\n    });\n  });\n})(CRM);\n\n//# sourceURL=/leave-absences/absence-tab/components/absence-tab-container.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/components/absence-tab-report.component',[\n  'leave-absences/absence-tab/modules/components'\n], function (components) {\n  components.component('absenceTabReport', {\n    bindings: {\n      contactId: '<'\n    },\n    templateUrl: ['settings', function (settings) {\n      return settings.pathTpl + 'components/absence-tab-report.html';\n    }],\n    controllerAs: 'report',\n    controller: ['$log', controller]\n  });\n\n  function controller ($log) {\n    $log.debug('Component: absence-tab-report');\n\n    var vm = this;\n  }\n});\n\n//# sourceURL=/leave-absences/absence-tab/components/absence-tab-report.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/components/absence-tab-entitlements.component',[\n  'leave-absences/absence-tab/modules/components'\n], function (components) {\n  components.component('absenceTabEntitlements', {\n    bindings: {\n      contactId: '<'\n    },\n    templateUrl: ['settings', function (settings) {\n      return settings.pathTpl + 'components/absence-tab-entitlements.html';\n    }],\n    controllerAs: 'entitlements',\n    controller: ['$log', controller]\n  });\n\n  function controller ($log) {\n    $log.debug('Component: absence-tab-entitlements');\n\n    var vm = {};\n\n    vm.contactId = this.contactId;\n\n    return vm;\n  }\n});\n\n//# sourceURL=/leave-absences/absence-tab/components/absence-tab-entitlements.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/components/absence-tab-custom-work-pattern-modal.component',[\n  'common/moment',\n  'leave-absences/absence-tab/modules/components'\n], function (moment, components) {\n  components.component('absenceTabCustomWorkPatternModal', {\n    bindings: {\n      contactId: '<',\n      dismiss: '&'\n    },\n    templateUrl: ['settings', function (settings) {\n      return settings.pathTpl + 'components/absence-tab-custom-work-pattern-modal.html';\n    }],\n    controllerAs: 'workPatternModal',\n    controller: ['$log', '$q', '$rootScope', 'OptionGroup', 'shared-settings', 'WorkPatternAPI', controller]\n  });\n\n  function controller ($log, $q, $rootScope, OptionGroup, sharedSettings, WorkPatternAPI) {\n    $log.debug('Component: absence-tab-custom-work-pattern-modal');\n\n    var vm = Object.create(this);\n\n    vm.changeReasons = [];\n    vm.errorMessage = '';\n    vm.saveInProgress = false;\n    vm.workPatterns = [];\n    vm.loading = { content: true };\n    vm.selected = {\n      workPattern: null,\n      effectiveDate: null,\n      changeReason: null\n    };\n    vm.uiOptions = {\n      effectiveDate: {\n        show: false,\n        options: {\n          startingDay: 1,\n          showWeeks: false\n        }\n      }\n    };\n\n    (function init () {\n      return $q.all([\n        loadWorkPatterns(),\n        loadJobContractRevisionChangeReasons()\n      ])\n      .finally(function () {\n        vm.loading.content = false;\n      });\n    })();\n\n    /**\n     * Closes the Work Pattern Modal\n     */\n    vm.closeModal = function () {\n      vm.dismiss({ $value: 'cancel' });\n    };\n\n    /**\n     * Closes the Error Message Alert box\n     */\n    vm.closeAlert = function () {\n      vm.errorMessage = '';\n    };\n\n    /**\n     * Assigns the Selected Work Pattern to the Contact\n     *\n     * @return {Promise}\n     */\n    vm.save = function () {\n      var serverFormattedEffectiveDate = moment(vm.selected.effectiveDate).format(sharedSettings.serverDateFormat);\n      vm.saveInProgress = true;\n\n      return WorkPatternAPI.assignWorkPattern(\n        vm.contactId, vm.selected.workPattern.id, serverFormattedEffectiveDate, null, vm.selected.changeReason)\n        .then(function () {\n          $rootScope.$broadcast('CustomWorkPattern::Added');\n          vm.closeModal();\n        })\n        .catch(handleError)\n        .finally(function () {\n          vm.saveInProgress = false;\n        });\n    };\n\n    /**\n     * Handles the error thrown by API\n     * @param {String} errorMessage\n     */\n    function handleError (errorMessage) {\n      vm.errorMessage = errorMessage;\n    }\n\n    /**\n     * Loads all the Work Patterns\n     *\n     * @return {Promise}\n     */\n    function loadWorkPatterns () {\n      return WorkPatternAPI.get()\n        .then(function (workPatterns) {\n          vm.workPatterns = workPatterns;\n        });\n    }\n\n    /**\n     * Loads the Job Contract Revision Change Reasons and indexes by `value`\n     *\n     * @return {Promise}\n     */\n    function loadJobContractRevisionChangeReasons () {\n      return OptionGroup.valuesOf('hrjc_revision_change_reason')\n        .then(function (reasons) {\n          vm.changeReasons = reasons;\n        });\n    }\n\n    return vm;\n  }\n});\n\n//# sourceURL=/leave-absences/absence-tab/components/absence-tab-custom-work-pattern-modal.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/components/absence-tab-work-patterns.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/absence-tab/modules/components',\n  'leave-absences/absence-tab/components/absence-tab-custom-work-pattern-modal.component'\n], function (_, moment, components) {\n  components.component('absenceTabWorkPatterns', {\n    bindings: {\n      contactId: '<'\n    },\n    templateUrl: ['settings', function (settings) {\n      return settings.pathTpl + 'components/absence-tab-work-patterns.html';\n    }],\n    controllerAs: 'workpatterns',\n    controller: [\n      '$log', '$q', '$rootElement', '$rootScope', '$uibModal', 'dialog', 'DateFormat', 'HR_settings',\n      'OptionGroup', 'WorkPattern', controller]\n  });\n\n  function controller ($log, $q, $rootElement, $rootScope, $uibModal, dialog, DateFormat, HRSettings, OptionGroup, WorkPattern) {\n    $log.debug('Component: absence-tab-work-patterns');\n\n    var changeReasons = [];\n    var vm = Object.create(this);\n\n    vm.customWorkPatterns = [];\n    vm.defaultWorkPattern = null;\n    vm.linkToWorkPatternListingPage = getWorkPatternListingPageURL();\n    vm.loading = {\n      workPattern: true\n    };\n\n    (function init () {\n      refresh([\n        loadJobContractRevisionChangeReasons(),\n        getDefaultWorkPattern(),\n        DateFormat.getDateFormat()\n      ]);\n\n      $rootScope.$on('CustomWorkPattern::Added', function () {\n        refresh();\n      });\n    })();\n\n    /**\n     * Shows a delete work pattern confirm dialog before deleting the contact work pattern\n     * @param {string} contactWorkPatternID\n     */\n    vm.deleteWorkPattern = function (contactWorkPatternID) {\n      dialog.open({\n        title: 'Confirm Deletion?',\n        copyCancel: 'Cancel',\n        copyConfirm: 'Confirm',\n        classConfirm: 'btn-danger',\n        msg: 'This cannot be undone',\n        onConfirm: function () {\n          WorkPattern.unassignWorkPattern(contactWorkPatternID)\n            .then(function () {\n              refresh();\n            });\n        }\n      });\n    };\n\n    /**\n     * Opens the Custom Work Pattern Modal\n     */\n    vm.openModal = function () {\n      $uibModal.open({\n        appendTo: $rootElement.children().eq(0),\n        template: '<absence-tab-custom-work-pattern-modal dismiss=\"$ctrl.dismiss()\" contact-id=\"' + vm.contactId + '\"/>',\n        controller: ['$uibModalInstance', function ($modalInstance) {\n          this.dismiss = $modalInstance.dismiss;\n        }],\n        controllerAs: '$ctrl'\n      });\n    };\n\n    /**\n     * Loads the custom work patterns,\n     * if no custom work pattern is found, calls the getDefaultWorkPattern()\n     *\n     * @return {Promise}\n     */\n    function getCustomWorkPatterns () {\n      return WorkPattern.workPatternsOf(vm.contactId, {}, false)\n        .then(function (workPatterns) {\n          vm.customWorkPatterns = workPatterns;\n        });\n    }\n\n    /**\n     * Loads the default work pattern\n     *\n     * @return {Promise}\n     */\n    function getDefaultWorkPattern () {\n      return WorkPattern.default()\n        .then(function (defaultWorkPattern) {\n          vm.defaultWorkPattern = defaultWorkPattern;\n        });\n    }\n\n    /**\n     * Loads the Job Contract Revision Change Reasons and indexes by `value`\n     *\n     * @return {Promise}\n     */\n    function loadJobContractRevisionChangeReasons () {\n      return OptionGroup.valuesOf('hrjc_revision_change_reason')\n        .then(function (reasons) {\n          changeReasons = _.indexBy(reasons, 'value');\n        });\n    }\n\n    /**\n     * Refreshes the view by loading work patterns\n     * @param {Promise/Array} promise\n     * @return {Promise}\n     */\n    function refresh (promise) {\n      var allPromises = [getCustomWorkPatterns()];\n      if (promise) {\n        allPromises = allPromises.concat(promise);\n      }\n\n      vm.loading.workPattern = true;\n      return $q.all(allPromises)\n        .then(function () {\n          setCustomWorkPatternProperties();\n        })\n        .finally(function () {\n          vm.loading.workPattern = false;\n        });\n    }\n\n    /**\n     * Sets the change reason label, and formats effective date to the custom work patterns\n     */\n    function setCustomWorkPatternProperties () {\n      var changeReason;\n      var dateFormat = HRSettings.DATE_FORMAT.toUpperCase();\n\n      vm.customWorkPatterns = _(vm.customWorkPatterns)\n        .map(function (workPattern) {\n          changeReason = changeReasons[workPattern.change_reason];\n          workPattern.change_reason_label = changeReason ? changeReason.label : '';\n\n          workPattern.effective_date = workPattern.effective_date\n            ? moment(workPattern.effective_date).format(dateFormat) : '';\n\n          return workPattern;\n        })\n        .sortBy(function (customWorkpattern) {\n          return -moment(customWorkpattern.effective_date, dateFormat).valueOf();\n        })\n        .value();\n    }\n\n    /**\n     * Returns the URL to the Work Pattern Listing Page.\n     *\n     * The given contact ID is added to the URL, as the cid parameter.\n     *\n     * @return {string}\n     */\n    function getWorkPatternListingPageURL () {\n      var path = 'civicrm/admin/leaveandabsences/work_patterns';\n      var returnPath = 'civicrm/contact/view';\n      var returnUrl = CRM.url(returnPath, { cid: vm.contactId, selectedChild: 'absence' });\n\n      return CRM.url(path, { cid: vm.contactId, returnUrl: returnUrl });\n    }\n\n    return vm;\n  }\n});\n\n//# sourceURL=/leave-absences/absence-tab/components/absence-tab-work-patterns.component.js"),eval("/* eslint-env amd */\n\n(function (CRM) {\n  define('leave-absences/absence-tab/components/annual-entitlements.component',[\n    'common/lodash',\n    'common/moment',\n    'leave-absences/absence-tab/modules/components',\n    'common/models/contact'\n  ], function (_, moment, components) {\n    components.component('annualEntitlements', {\n      bindings: {\n        contactId: '<'\n      },\n      templateUrl: ['settings', function (settings) {\n        return settings.pathTpl + 'components/annual-entitlements.html';\n      }],\n      controllerAs: 'entitlements',\n      controller: ['$log', '$q', 'AbsenceType', 'AbsencePeriod', 'Entitlement', 'Contact', 'notificationService', controller]\n    });\n\n    function controller ($log, $q, AbsenceType, AbsencePeriod, Entitlement, Contact, notification) {\n      $log.debug('Component: annual-entitlements');\n\n      var vm = this;\n      var contacts = [];\n      var allEntitlements = [];\n\n      vm.absencePeriods = [];\n      vm.absenceTypes = [];\n      vm.loading = { absencePeriods: true };\n      vm.editEntitlementsPageUrl = getEditEntitlementsPageURL(vm.contactId);\n\n      (function init () {\n        return $q.all([\n          loadAbsenceTypes(),\n          loadEntitlements()\n        ])\n        .then(function () {\n          return loadCommentsAuthors();\n        })\n        .then(function () {\n          return loadAbsencePeriods();\n        })\n        .finally(function () {\n          vm.loading.absencePeriods = false;\n        });\n      })();\n\n      /**\n       * Shows a comment to the entitlement\n       *\n       * @param {Object} comment\n       */\n      vm.showComment = function (comment) {\n        /*\n         * @TODO There is no support for footer in notificationService at the moment.\n         * This code should be refactored as soon as notificationService supports footer.\n         * At the moment the footer is constructed via rich HTML directly via body text\n         */\n        var text = comment.message +\n          '<br/><br/><strong>Last updated:' +\n          '<br/>By: ' + comment.author_name +\n          '<br/>Date: ' + moment.utc(comment.date).local().format('DD/M/YYYY HH:mm') +\n          '</strong>';\n\n        notification.info('Calculation comment:', text);\n      };\n\n      /**\n       * Loads absence periods\n       *\n       * @return {Promise}\n       */\n      function loadAbsencePeriods () {\n        return AbsencePeriod.all().then(setAbsencePeriodsProps);\n      }\n\n      /**\n       * Loads absence types\n       *\n       * @return {Promise}\n       */\n      function loadAbsenceTypes () {\n        return AbsenceType.all()\n          .then(function (data) {\n            vm.absenceTypes = data;\n          });\n      }\n\n      /**\n       * Loads entitlements comments authors\n       *\n       * @return {Promise}\n       */\n      function loadCommentsAuthors () {\n        var authorsIDs = _.uniq(_.map(allEntitlements, function (entitlement) {\n          return entitlement.comment_author_id;\n        }));\n\n        return Contact.all({ id: { 'IN': authorsIDs } })\n          .then(function (data) {\n            contacts = _.indexBy(data.list, 'contact_id');\n          });\n      }\n\n      /**\n       * Loads entitlements\n       *\n       * @return {Promise}\n       */\n      function loadEntitlements () {\n        return Entitlement.all({ contact_id: vm.contactId })\n          .then(function (data) {\n            allEntitlements = data;\n          });\n      }\n\n      /**\n       * Processes entitlements from data and sets them to the controller\n       *\n       * @param {Object} absencePeriods\n       */\n      function setAbsencePeriodsProps (absencePeriods) {\n        // Get all periods as per entitlements\n        var periods = _.uniq(_.map(allEntitlements, function (entitlement) {\n          return entitlement.period_id;\n        }));\n\n        // Filter periods needed for loaded entitlements only\n        absencePeriods = _.filter(absencePeriods, function (absencePeriod) {\n          return periods.indexOf(absencePeriod.id) !== -1;\n        });\n        absencePeriods = _.sortBy(absencePeriods, function (absencePeriod) {\n          return -moment(absencePeriod.start_date).valueOf();\n        });\n        vm.absencePeriods = _.map(absencePeriods, function (absencePeriod) {\n          var entitlements = _.map(vm.absenceTypes, function (absenceType) {\n            var leave = _.filter(allEntitlements, function (entitlement) {\n              return entitlement.type_id === absenceType.id && entitlement.period_id === absencePeriod.id;\n            })[0];\n\n            return leave ? {\n              amount: leave.value,\n              comment: leave.comment ? {\n                message: leave.comment,\n                author_name: contacts[leave.comment_author_id].display_name,\n                date: leave.comment_date\n              } : null\n            } : null;\n          });\n\n          return {\n            period: absencePeriod.title,\n            entitlements: entitlements\n          };\n        });\n      }\n\n      /**\n        * Returns the URL to the Manage Entitlement page.\n        *\n        * The given contact ID is added to the URL, as the cid parameter.\n        *\n        * @param {number} contactId\n        * @return {string}\n        */\n      function getEditEntitlementsPageURL (contactId) {\n        var path = 'civicrm/admin/leaveandabsences/periods/manage_entitlements';\n        var returnPath = 'civicrm/contact/view';\n        var returnUrl = CRM.url(returnPath, { cid: contactId, selectedChild: 'absence' });\n        return CRM.url(path, { cid: contactId, returnUrl: returnUrl });\n      }\n\n      return vm;\n    }\n  });\n})(CRM);\n\n//# sourceURL=/leave-absences/absence-tab/components/annual-entitlements.component.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/components/contract-entitlements.component',[\n  'common/lodash',\n  'common/moment',\n  'leave-absences/absence-tab/modules/components',\n  'common/models/contract'\n], function (_, moment, components) {\n  components.component('contractEntitlements', {\n    bindings: {\n      contactId: '<'\n    },\n    templateUrl: ['settings', function (settings) {\n      return settings.pathTpl + 'components/contract-entitlements.html';\n    }],\n    controllerAs: 'entitlements',\n    controller: ['$log', '$q', 'HR_settings', 'AbsenceType', 'Contract', 'DateFormat', controller]\n  });\n\n  function controller ($log, $q, HRSettings, AbsenceType, Contract, DateFormat) {\n    $log.debug('Component: contract-entitlements');\n\n    var vm = this;\n\n    vm.absenceTypes = [];\n    vm.contracts = [];\n    vm.loading = { contracts: true };\n\n    (function init () {\n      return $q.all([\n        loadAbsenceTypes(),\n        DateFormat.getDateFormat()\n      ])\n      .then(function () {\n        return loadContracts();\n      })\n      .finally(function () {\n        vm.loading.contracts = false;\n      });\n    })();\n\n    /**\n     * Formats the date according to user settings\n     *\n     * @param {Object} date\n     * @return {string}\n     */\n    function formatDate (date) {\n      var dateFormat = HRSettings.DATE_FORMAT.toUpperCase();\n\n      return date ? moment(date).format(dateFormat) : '';\n    }\n\n    /**\n     * Loads absence types\n     *\n     * @return {Promise}\n     */\n    function loadAbsenceTypes () {\n      return AbsenceType.all()\n        .then(function (data) {\n          vm.absenceTypes = data;\n        });\n    }\n\n    /**\n     * Loads contracts\n     *\n     * @return {Promise}\n     */\n    function loadContracts () {\n      return Contract.all({ contact_id: vm.contactId })\n        .then(function (data) {\n          setContractsProps(data);\n        });\n    }\n\n    /**\n     * Processes contracts from data and sets them to a controller\n     *\n     * @param {Object} contracts\n     */\n    function setContractsProps (contracts) {\n      vm.contracts = _.sortBy(contracts, function (contract) {\n        return moment(contract.info.details.period_start_date);\n      }).map(function (contract) {\n        var info = contract.info;\n        var details = info.details;\n        var absences = _.map(vm.absenceTypes, function (absenceType) {\n          var leave = _.filter(info.leave, function (leave) {\n            return leave.leave_type === absenceType.id;\n          })[0];\n\n          return {\n            amount: leave ? leave.leave_amount : ''\n          };\n        });\n\n        return {\n          'position': details.position,\n          'start_date': formatDate(details.period_start_date),\n          'end_date': formatDate(details.period_end_date),\n          'absences': absences\n        };\n      });\n    }\n\n    return vm;\n  }\n});\n\n//# sourceURL=/leave-absences/absence-tab/components/contract-entitlements.component.js"),eval("(function (CRM) {\n  define('leave-absences/absence-tab/modules/settings',[\n    'common/angular'\n  ], function (angular) {\n    return angular.module('absence-tab.settings', []).constant('settings', {\n      contactId: CRM.vars.leaveAndAbsences.contactId,\n      debug: CRM.debug,\n      pathTpl: CRM.vars.leaveAndAbsences.baseURL + '/views/absence-tab/'\n    });\n  });\n})(CRM);\n\n//# sourceURL=/leave-absences/absence-tab/modules/settings.js"),eval("(function (CRM) {\n  define('leave-absences/absence-tab/modules/config',[\n    'common/angular',\n    'leave-absences/absence-tab/modules/settings',\n  ], function (angular) {\n    return angular.module('absence-tab.config', ['absence-tab.settings'])\n      .config([\n        '$resourceProvider', '$httpProvider', '$logProvider', 'settings',\n        function ($resourceProvider, $httpProvider, $logProvider, settings) {\n          $logProvider.debugEnabled(settings.debug);\n\n          $resourceProvider.defaults.stripTrailingSlashes = false;\n          $httpProvider.defaults.headers.common[\"X-Requested-With\"] = 'XMLHttpRequest';\n        }\n      ]);\n  });\n})(CRM);\n\n//# sourceURL=/leave-absences/absence-tab/modules/config.js"),eval("/* eslint-env amd */\n\ndefine('leave-absences/absence-tab/app',[\n  'common/angular',\n  'common/angularBootstrap',\n  'common/text-angular',\n  'common/modules/dialog',\n  'common/services/check-permissions',\n  'common/services/angular-date/date-format',\n  'common/modules/directives',\n  'common/services/notification.service',\n  'leave-absences/shared/modules/shared-settings',\n  'leave-absences/shared/models/absence-type.model',\n  'leave-absences/shared/models/calendar.model',\n  'leave-absences/shared/models/entitlement.model',\n  'leave-absences/shared/models/leave-request.model',\n  'leave-absences/shared/models/work-pattern.model',\n  'leave-absences/shared/components/leave-calendar.component',\n  'leave-absences/shared/components/leave-calendar-day.component',\n  'leave-absences/shared/components/leave-calendar-legend.component',\n  'leave-absences/shared/components/leave-calendar-month.component',\n  'leave-absences/shared/components/leave-request-actions.component',\n  'leave-absences/shared/components/leave-request-popup-comments-tab.component',\n  'leave-absences/shared/components/leave-request-popup-details-tab.component',\n  'leave-absences/shared/components/leave-request-popup-files-tab',\n  'leave-absences/shared/components/leave-request-record-actions.component',\n  'leave-absences/shared/components/staff-leave-report.component',\n  'leave-absences/shared/controllers/sub-controllers/leave-request.controller',\n  'leave-absences/shared/controllers/sub-controllers/sick-request.controller',\n  'leave-absences/shared/controllers/sub-controllers/toil-request.controller',\n  'leave-absences/shared/models/absence-type.model',\n  'leave-absences/shared/models/calendar.model',\n  'leave-absences/shared/models/leave-request.model',\n  'leave-absences/shared/models/work-pattern.model',\n  'leave-absences/shared/models/absence-type.model',\n  'leave-absences/shared/models/entitlement.model',\n  'leave-absences/shared/modules/shared-settings',\n  'leave-absences/shared/services/leave-popup.service',\n  'leave-absences/absence-tab/components/absence-tab-container.component',\n  'leave-absences/absence-tab/components/absence-tab-report.component',\n  'leave-absences/absence-tab/components/absence-tab-entitlements.component',\n  'leave-absences/absence-tab/components/absence-tab-work-patterns.component',\n  'leave-absences/absence-tab/components/annual-entitlements.component',\n  'leave-absences/absence-tab/components/contract-entitlements.component',\n  'leave-absences/absence-tab/modules/config'\n], function (angular) {\n  angular.module('absence-tab', [\n    'ngResource',\n    'ui.bootstrap',\n    'textAngular',\n    'common.angularDate',\n    'common.dialog',\n    'common.directives',\n    'common.services',\n    /*\n     * @TODO Because the app requires Contact, which requires Group,\n     * which requires api.group.mock and api.group-contact.mock,\n     * we need to include 'common.mocks' in the production app.\n     * This needs to be refactored.\n     */\n    'common.mocks',\n    'leave-absences.settings',\n    'leave-absences.models',\n    'leave-absences.components',\n    'leave-absences.controllers',\n    'leave-absences.models',\n    'leave-absences.services',\n    'leave-absences.settings',\n    'absence-tab.config',\n    'absence-tab.components'\n  ]).run(['$log', '$rootScope', 'shared-settings', 'settings', function ($log, $rootScope, sharedSettings, settings) {\n    $log.debug('app.run');\n\n    $rootScope.sharedPathTpl = sharedSettings.sharedPathTpl;\n    $rootScope.settings = settings;\n  }]);\n\n  return angular;\n});\n\n//# sourceURL=/leave-absences/absence-tab/app.js"),eval("(function (CRM, require) {\n  var srcPath = CRM.vars.leaveAndAbsences.baseURL + '/js/angular/src/leave-absences';\n\n  require.config({\n    urlArgs: 'bust=' + (new Date()).getTime(),\n    paths: {\n      'leave-absences/shared': srcPath + '/shared',\n      'leave-absences/absence-tab': srcPath + '/absence-tab'\n    }\n  });\n\n  require(['leave-absences/shared/config'], function () {\n    require([\n      'leave-absences/absence-tab/app'\n    ],\n    function () {\n      document.dispatchEvent(typeof window.CustomEvent === 'function' ? new CustomEvent('absenceTabReady') : (function () {\n        var e = document.createEvent('Event');\n        e.initEvent('absenceTabReady', true, true);\n        return e;\n      })());\n    });\n  });\n})(CRM, require);\n\n//# sourceURL=/absence-tab.js"),define("absence-tab",function(){});
//# sourceMappingURL=absence-tab.js.map